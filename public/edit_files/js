

/* js/showhide.js */

var showHide={init:function(k){var g=(k)?YDom.get(k):document;
var h=YDom.getElementsByClassName("showhide-block","*",g);
for(var f=0;
f<h.length;
f++){LI.hide(h[f])
}var b=YDom.getElementsByClassName("showhide-link","*",g);
for(var e=0;
e<b.length;
e++){var d=b[e].getElementsByTagName("a");
for(var c=0;
c<d.length;
c++){YEvent.on(d[c],"click",showHide.toggle);
d[c].onclick=function(){return false
};
if(/-show/.test(d[c].id)){b[e].style.display="block"
}}}},toggle:function(d){var b=YEvent.getTarget(d);
var a=b.id;
var g=a.split("-")[0];
var c=a.split("-")[1];
var f=YDom.get(g);
if(c=="show"){LI.show(f);
if(YDom.get(g+"-hide")){YDom.get(g+"-hide").parentNode.style.display="block"
}}else{LI.hide(f);
YDom.get(g+"-show").parentNode.style.display="block"
}LI.hide(b.parentNode)
}};

/* js/profile.js */

var profileSwitch=function(){function a(){var c=document.getElementById("nav-profile-lang");
var d=document.getElementById("current-locale");
var b=document.getElementById("nav-profile-lang-list");
YEvent.on(d,"mouseover",function(){YDom.addClass(c,"hover")
});
YEvent.on(b,"mouseover",function(){YDom.addClass(c,"hover")
});
YEvent.on(c,"mouseout",function(){YDom.removeClass(c,"hover")
})
}return{init:function(){if(!document.getElementById("nav-profile-lang")){return false
}a()
}}
}();
YEvent.on(window,"load",profileSwitch.init);
var toggleWarning=function(){var b=document.getElementById("locale-createInternationalProfile");
var a=document.getElementById("unsupported");
var d=function(){b.onchange=function(){c()
}
};
var c=function(){for(var e=0;
supportedLanguages.length>e;
e++){var f=supportedLanguages[e];
if(b.options[b.selectedIndex].value==f){LI.hide(a);
break
}else{LI.show(a)
}}};
return{init:function(){if(!document.getElementById||!document.getElementById("locale-createInternationalProfile")){return
}d()
}}
}();
YEvent.on(window,"load",toggleWarning.init);
var flagPhotoForm={init:function(){if(!document.getElementById||!document.getElementById("flag-form")){return
}var a=YDom.getElementsByClassName("flag-photo","li")[0].getElementsByTagName("a")[0];
var c=YDom.getElementsByClassName("profile-control","div")[0];
var b=document.getElementById("cancel-flag");
a.onclick=function(){YDom.addClass(c,"open");
return false
};
b.onclick=function(){YDom.removeClass(c,"open");
return false
}
}};
YEvent.on(window,"load",flagPhotoForm.init);
var bubbleInfo=function(){return{init:function(){if(!YDom.get("introlink-bot")){return
}var a=YDom.get("introlink-bot");
if(a.nextSibling&&/bubble/.test(a.nextSibling.className)){a.onmouseover=a.onmouseout=function(){LI.toggle(this.nextSibling)
}
}}}
}();
YEvent.on(window,"load",bubbleInfo.init);
var profileExperts={init:function(){if(!document.getElementById||!document.getElementById("experts")){return
}var e=document.getElementById("experts");
var d=e.getElementsByTagName("li");
if(d.length>4){var b=document.getElementById("nobullet").style.display="list-item";
var c=document.getElementById("see-more-experts");
var a=d.length-1;
c.onclick=function(){profileExperts.toggleExperts(d,a);
return false
};
profileExperts.showExpertsOnInit(d,a)
}},toggleExperts:function(c,a){var d=0;
if(c[3].style.display=="list-item"){profileExperts.showExpertsOnInit(c,a)
}else{for(var b=0;
c.length>b;
b++){if(b<a){if(b>2){c[b].style.display="list-item";
d++
}}}document.getElementById("see-more-experts").innerHTML=i18n.seeLess
}},showExpertsOnInit:function(d,b){var f=0;
for(var c=0;
d.length>c;
c++){if(c<b){if(c>2){LI.hide(d[c]);
f++
}}}var a;
if(f==1){a=i18n.other
}else{a=i18n.others
}var e=i18n.and+" "+f+" "+a;
document.getElementById("see-more-experts").innerHTML=e
}};
var profileRecs={sets:null,showlinks:null,selectedSet:null,init:function(){if(!document.getElementById||!document.getElementById("showlinks-rec")){return
}profileRecs.showlinks=document.getElementById("showlinks-rec").getElementsByTagName("a");
for(var a=0;
a<profileRecs.showlinks.length;
a++){profileRecs.showlinks[a].onclick=function(){profileRecs.toggleSets(this);
return false
}
}profileRecs.sets=YDom.getElementsByClassName("recset","div");
profileRecs.hideAllSets();
profileRecs.showSet(profileRecs.selectedSet);
profileRecs.updateLinkClasses(profileRecs.selectedSet)
},toggleSets:function(a){profileRecs.hideAllSets();
var b=a.href.split("#")[1];
profileRecs.showSet(b);
profileRecs.updateLinkClasses(b)
},showSet:function(a){LI.show("recset_"+a)
},hideAllSets:function(){for(var a=0;
a<profileRecs.sets.length;
a++){LI.hide(profileRecs.sets[a])
}},updateLinkClasses:function(b){for(var a=0;
a<profileRecs.showlinks.length;
a++){YDom.removeClass(profileRecs.showlinks[a],"chosen");
if(profileRecs.showlinks[a].href.split("#")[1]==b){YDom.addClass(profileRecs.showlinks[a],"chosen")
}}}};
var profileQa={init:function(){if(!document.getElementById||!document.getElementById("showlinks-qa")){return
}LI.hide("hdr-q");
LI.hide("hdr-a");
var c=YDom.get("showlinks-qa");
var a=c.getElementsByTagName("a");
for(var b=0;
a.length>b;
b++){a[b].onclick=function(){profileQa.toggleQA(this.id);
return false
}
}if(isQuestionMode){profileQa.toggleQA("qLink")
}else{profileQa.toggleQA("aLink")
}},toggleQA:function(a){if(a=="qLink"){if(YDom.get("my-q")){LI.show("my-q")
}if(YDom.get("my-a")){LI.hide("my-a")
}if(YDom.get("qLink")){YDom.get("qLink").className="on"
}if(YDom.get("aLink")){YDom.get("aLink").className="off"
}}else{if(YDom.get("my-q")){LI.hide("my-q")
}if(YDom.get("my-a")){LI.show("my-a")
}if(YDom.get("qLink")){YDom.get("qLink").className="off"
}if(YDom.get("aLink")){YDom.get("aLink").className="on"
}}}};
YEvent.on(window,"load",profileQa.init);
(function(){function b(){var f=YDom.getElementsByClassName("primary-profile-content");
var d;
for(var c=0;
c<f.length;
c++){d=f[c];
var e=document.createElement("span");
e.className="control";
d.appendChild(e);
YDom.addClass(d,"collapse-open");
e._content=d;
f._control=e;
YEvent.on(e,"click",a)
}}function a(){var d=this;
var c=d._content;
if(YDom.hasClass(c,"collapse-open")){YDom.replaceClass(c,"collapse-open","collapse-close")
}else{YDom.replaceClass(c,"collapse-close","collapse-open")
}}YEvent.onDOMReady(b)
})();
function ToggleModuleVisibility(b,a){YEvent.on(b,"click",this.toggle,a)
}ToggleModuleVisibility.prototype={toggle:function(a,b){var c=YDom.get(b.parentID);
if(YDom.hasClass(c,"open")){YDom.removeClass(c,"open");
YDom.addClass(c,"close");
oUISettings.saveSettings(b.setting,"true")
}else{YDom.removeClass(c,"close");
YDom.addClass(c,"open");
oUISettings.saveSettings(b.setting,"false")
}}};
function ConnectionBrowseVcard(c,b){var a=c.getElementsByTagName("li");
YAHOO.util.Event.addListener(a,"mouseover",function(d){YAHOO.util.Dom.addClass(this,"hover")
});
YAHOO.util.Event.addListener(a,"mouseout",function(d){YAHOO.util.Dom.removeClass(this,"hover")
})
}function getRegionAndCityOptions(d,e){if(!e||typeof(e)!="object"||!e.countryFieldId||!e.postalCodeId||!e.resultsContainerId||!e.requestURL){return
}var j=document.getElementById(e.countryFieldId),b=document.getElementById(e.postalCodeId),g=document.getElementById(e.resultsContainerId),h=Y$("ul",g,true);
var c=h.innerHTML,f=null,a=null,i=null;
resetEl=function(){h.innerHTML=c;
g.style.display="none"
};
goGetMatchingLocations=function(m){clearTimeout(i);
resetEl();
var k=function(t){try{var s=YAHOO.lang.JSON.parse(t.responseText);
if(s&&s.formOptions&&s.formOptions.length>0){a="";
for(var q=0,p=s.formOptions.length;
q<p;
q++){a+='<li><label><input type="radio" name="'+s.formKey+'" value="'+s.formOptions[q].formValue+'" ';
if(s.checkedValue==s.formOptions[q].formValue){a+=' checked="checked" '
}a+="/> "+s.formOptions[q].formLabel+"</label></li>"
}h.innerHTML=a;
g.style.display="block"
}}catch(r){return
}};
var n={success:k};
var l=function(){YAHOO.util.Connect.asyncRequest("GET",e.requestURL+((e.requestURL.indexOf("?")>0)?"&":"?")+"countryCode="+j.options[j.selectedIndex].value+"&postalCode="+b.value,n)
};
i=setTimeout(l,300)
};
if(j&&b&&g&&h){YEvent.on(j,"change",goGetMatchingLocations);
YEvent.on(b,"keyup",goGetMatchingLocations)
}goGetMatchingLocations()
};

/* js/util/ToggleClass.js */

LI.define("ToggleClass");
LI.define("ToggleClasses");
LI.ToggleClass=function(c,b){var a;
b={classname:b.classname||"toggled",on:b.on||"body",stopEvent:(b.stopEvent==false)?false:true,enableBeforeToggleEvent:(b.enableBeforeToggleEvent==false)?false:true,targetSelector:b.targetSelector};
if(b.enableBeforeToggleEvent){this.beforeToggleEvent=new YAHOO.util.CustomEvent("searchBegin")
}if(typeof(b.on)=="string"){b.on=[b.on]
}YEvent.addListener(c,"click",function(h){if(b.targetSelector&&!Sizzle.matches(b.targetSelector,[YEvent.getTarget(h)]).length){return
}if(b.stopEvent===true){YEvent.preventDefault(h)
}if(b.enableBeforeToggleEvent){this.beforeToggleEvent.fire()
}for(var f=0,g=b.on.length;
f<g;
f++){a=Y$(b.on[f]);
for(var d=0,k=a.length;
d<k;
d++){LI.toggleClass(a[d],b.classname)
}}},this,true)
};

/* lib/yui/2.8.1_li/dragdrop/dragdrop.js */

/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.1
*/
/**
 * The drag and drop utility provides a framework for building drag and drop
 * applications.  In addition to enabling drag and drop for specific elements,
 * the drag and drop elements are tracked by the manager class, and the
 * interactions between the various elements are tracked during the drag and
 * the implementing code is notified about these important moments.
 * @module dragdrop
 * @title Drag and Drop
 * @requires yahoo,dom,event
 * @namespace YAHOO.util
 */

// Only load the library once.  Rewriting the manager class would orphan 
// existing drag and drop instances.
if (!YAHOO.util.DragDropMgr) {

/**
 * DragDropMgr is a singleton that tracks the element interaction for 
 * all DragDrop items in the window.  Generally, you will not call 
 * this class directly, but it does have helper methods that could 
 * be useful in your DragDrop implementations.
 * @class DragDropMgr
 * @static
 */
YAHOO.util.DragDropMgr = function() {

    var Event = YAHOO.util.Event,
        Dom = YAHOO.util.Dom;

    return {
        /**
        * This property is used to turn on global use of the shim element on all DragDrop instances, defaults to false for backcompat. (Use: YAHOO.util.DDM.useShim = true)
        * @property useShim
        * @type Boolean
        * @static
        */
        useShim: false,
        /**
        * This property is used to determine if the shim is active over the screen, default false.
        * @private
        * @property _shimActive
        * @type Boolean
        * @static
        */
        _shimActive: false,
        /**
        * This property is used when useShim is set on a DragDrop object to store the current state of DDM.useShim so it can be reset when a drag operation is done.
        * @private
        * @property _shimState
        * @type Boolean
        * @static
        */
        _shimState: false,
        /**
        * This property is used when useShim is set to true, it will set the opacity on the shim to .5 for debugging. Use: (YAHOO.util.DDM._debugShim = true;)
        * @private
        * @property _debugShim
        * @type Boolean
        * @static
        */
        _debugShim: false,
        /**
        * This method will create a shim element (giving it the id of yui-ddm-shim), it also attaches the mousemove and mouseup listeners to it and attaches a scroll listener on the window
        * @private
        * @method _sizeShim
        * @static
        */
        _createShim: function() {
            var s = document.createElement('div');
            s.id = 'yui-ddm-shim';
            if (document.body.firstChild) {
                document.body.insertBefore(s, document.body.firstChild);
            } else {
                document.body.appendChild(s);
            }
            s.style.display = 'none';
            s.style.backgroundColor = 'red';
            s.style.position = 'absolute';
            s.style.zIndex = '99999';
            Dom.setStyle(s, 'opacity', '0');
            this._shim = s;
            Event.on(s, "mouseup",   this.handleMouseUp, this, true);
            Event.on(s, "mousemove", this.handleMouseMove, this, true);
            Event.on(window, 'scroll', this._sizeShim, this, true);
        },
        /**
        * This method will size the shim, called from activate and on window scroll event
        * @private
        * @method _sizeShim
        * @static
        */
        _sizeShim: function() {
            if (this._shimActive) {
                var s = this._shim;
                s.style.height = Dom.getDocumentHeight() + 'px';
                s.style.width = Dom.getDocumentWidth() + 'px';
                s.style.top = '0';
                s.style.left = '0';
            }
        },
        /**
        * This method will create the shim element if needed, then show the shim element, size the element and set the _shimActive property to true
        * @private
        * @method _activateShim
        * @static
        */
        _activateShim: function() {
            if (this.useShim) {
                if (!this._shim) {
                    this._createShim();
                }
                this._shimActive = true;
                var s = this._shim,
                    o = '0';
                if (this._debugShim) {
                    o = '.5';
                }
                Dom.setStyle(s, 'opacity', o);
                this._sizeShim();
                s.style.display = 'block';
            }
        },
        /**
        * This method will hide the shim element and set the _shimActive property to false
        * @private
        * @method _deactivateShim
        * @static
        */
        _deactivateShim: function() {
            this._shim.style.display = 'none';
            this._shimActive = false;
        },
        /**
        * The HTML element created to use as a shim over the document to track mouse movements
        * @private
        * @property _shim
        * @type HTMLElement
        * @static
        */
        _shim: null,
        /**
         * Two dimensional Array of registered DragDrop objects.  The first 
         * dimension is the DragDrop item group, the second the DragDrop 
         * object.
         * @property ids
         * @type {string: string}
         * @private
         * @static
         */
        ids: {},

        /**
         * Array of element ids defined as drag handles.  Used to determine 
         * if the element that generated the mousedown event is actually the 
         * handle and not the html element itself.
         * @property handleIds
         * @type {string: string}
         * @private
         * @static
         */
        handleIds: {},

        /**
         * the DragDrop object that is currently being dragged
         * @property dragCurrent
         * @type DragDrop
         * @private
         * @static
         **/
        dragCurrent: null,

        /**
         * the DragDrop object(s) that are being hovered over
         * @property dragOvers
         * @type Array
         * @private
         * @static
         */
        dragOvers: {},

        /**
         * the X distance between the cursor and the object being dragged
         * @property deltaX
         * @type int
         * @private
         * @static
         */
        deltaX: 0,

        /**
         * the Y distance between the cursor and the object being dragged
         * @property deltaY
         * @type int
         * @private
         * @static
         */
        deltaY: 0,

        /**
         * Flag to determine if we should prevent the default behavior of the
         * events we define. By default this is true, but this can be set to 
         * false if you need the default behavior (not recommended)
         * @property preventDefault
         * @type boolean
         * @static
         */
        preventDefault: true,

        /**
         * Flag to determine if we should stop the propagation of the events 
         * we generate. This is true by default but you may want to set it to
         * false if the html element contains other features that require the
         * mouse click.
         * @property stopPropagation
         * @type boolean
         * @static
         */
        stopPropagation: true,

        /**
         * Internal flag that is set to true when drag and drop has been
         * initialized
         * @property initialized
         * @private
         * @static
         */
        initialized: false,

        /**
         * All drag and drop can be disabled.
         * @property locked
         * @private
         * @static
         */
        locked: false,

        /**
         * Provides additional information about the the current set of
         * interactions.  Can be accessed from the event handlers. It
         * contains the following properties:
         *
         *       out:       onDragOut interactions
         *       enter:     onDragEnter interactions
         *       over:      onDragOver interactions
         *       drop:      onDragDrop interactions
         *       point:     The location of the cursor
         *       draggedRegion: The location of dragged element at the time
         *                      of the interaction
         *       sourceRegion: The location of the source elemtn at the time
         *                     of the interaction
         *       validDrop: boolean
         * @property interactionInfo
         * @type object
         * @static
         */
        interactionInfo: null,

        /**
         * Called the first time an element is registered.
         * @method init
         * @private
         * @static
         */
        init: function() {
            this.initialized = true;
        },

        /**
         * In point mode, drag and drop interaction is defined by the 
         * location of the cursor during the drag/drop
         * @property POINT
         * @type int
         * @static
         * @final
         */
        POINT: 0,

        /**
         * In intersect mode, drag and drop interaction is defined by the 
         * cursor position or the amount of overlap of two or more drag and 
         * drop objects.
         * @property INTERSECT
         * @type int
         * @static
         * @final
         */
        INTERSECT: 1,

        /**
         * In intersect mode, drag and drop interaction is defined only by the 
         * overlap of two or more drag and drop objects.
         * @property STRICT_INTERSECT
         * @type int
         * @static
         * @final
         */
        STRICT_INTERSECT: 2,

        /**
         * The current drag and drop mode.  Default: POINT
         * @property mode
         * @type int
         * @static
         */
        mode: 0,

        /**
         * Runs method on all drag and drop objects
         * @method _execOnAll
         * @private
         * @static
         */
        _execOnAll: function(sMethod, args) {
            for (var i in this.ids) {
                for (var j in this.ids[i]) {
                    var oDD = this.ids[i][j];
                    if (! this.isTypeOfDD(oDD)) {
                        continue;
                    }
                    oDD[sMethod].apply(oDD, args);
                }
            }
        },

        /**
         * Drag and drop initialization.  Sets up the global event handlers
         * @method _onLoad
         * @private
         * @static
         */
        _onLoad: function() {

            this.init();

            Event.on(document, "mouseup",   this.handleMouseUp, this, true);
            Event.on(document, "mousemove", this.handleMouseMove, this, true);
            Event.on(window,   "unload",    this._onUnload, this, true);
            Event.on(window,   "resize",    this._onResize, this, true);
            // Event.on(window,   "mouseout",    this._test);

        },

        /**
         * Reset constraints on all drag and drop objs
         * @method _onResize
         * @private
         * @static
         */
        _onResize: function(e) {
            this._execOnAll("resetConstraints", []);
        },

        /**
         * Lock all drag and drop functionality
         * @method lock
         * @static
         */
        lock: function() { this.locked = true; },

        /**
         * Unlock all drag and drop functionality
         * @method unlock
         * @static
         */
        unlock: function() { this.locked = false; },

        /**
         * Is drag and drop locked?
         * @method isLocked
         * @return {boolean} True if drag and drop is locked, false otherwise.
         * @static
         */
        isLocked: function() { return this.locked; },

        /**
         * Location cache that is set for all drag drop objects when a drag is
         * initiated, cleared when the drag is finished.
         * @property locationCache
         * @private
         * @static
         */
        locationCache: {},

        /**
         * Set useCache to false if you want to force object the lookup of each
         * drag and drop linked element constantly during a drag.
         * @property useCache
         * @type boolean
         * @static
         */
        useCache: true,

        /**
         * The number of pixels that the mouse needs to move after the 
         * mousedown before the drag is initiated.  Default=3;
         * @property clickPixelThresh
         * @type int
         * @static
         */
        clickPixelThresh: 3,

        /**
         * The number of milliseconds after the mousedown event to initiate the
         * drag if we don't get a mouseup event. Default=1000
         * @property clickTimeThresh
         * @type int
         * @static
         */
        clickTimeThresh: 1000,

        /**
         * Flag that indicates that either the drag pixel threshold or the 
         * mousdown time threshold has been met
         * @property dragThreshMet
         * @type boolean
         * @private
         * @static
         */
        dragThreshMet: false,

        /**
         * Timeout used for the click time threshold
         * @property clickTimeout
         * @type Object
         * @private
         * @static
         */
        clickTimeout: null,

        /**
         * The X position of the mousedown event stored for later use when a 
         * drag threshold is met.
         * @property startX
         * @type int
         * @private
         * @static
         */
        startX: 0,

        /**
         * The Y position of the mousedown event stored for later use when a 
         * drag threshold is met.
         * @property startY
         * @type int
         * @private
         * @static
         */
        startY: 0,

        /**
         * Flag to determine if the drag event was fired from the click timeout and
         * not the mouse move threshold.
         * @property fromTimeout
         * @type boolean
         * @private
         * @static
         */
        fromTimeout: false,

        /**
         * Each DragDrop instance must be registered with the DragDropMgr.  
         * This is executed in DragDrop.init()
         * @method regDragDrop
         * @param {DragDrop} oDD the DragDrop object to register
         * @param {String} sGroup the name of the group this element belongs to
         * @static
         */
        regDragDrop: function(oDD, sGroup) {
            if (!this.initialized) { this.init(); }
            
            if (!this.ids[sGroup]) {
                this.ids[sGroup] = {};
            }
            this.ids[sGroup][oDD.id] = oDD;
        },

        /**
         * Removes the supplied dd instance from the supplied group. Executed
         * by DragDrop.removeFromGroup, so don't call this function directly.
         * @method removeDDFromGroup
         * @private
         * @static
         */
        removeDDFromGroup: function(oDD, sGroup) {
            if (!this.ids[sGroup]) {
                this.ids[sGroup] = {};
            }

            var obj = this.ids[sGroup];
            if (obj && obj[oDD.id]) {
                delete obj[oDD.id];
            }
        },

        /**
         * Unregisters a drag and drop item.  This is executed in 
         * DragDrop.unreg, use that method instead of calling this directly.
         * @method _remove
         * @private
         * @static
         */
        _remove: function(oDD) {
            for (var g in oDD.groups) {
                if (g) {
                    var item = this.ids[g];
                    if (item && item[oDD.id]) {
                        delete item[oDD.id];
                    }
                }
                
            }
            delete this.handleIds[oDD.id];
        },

        /**
         * Each DragDrop handle element must be registered.  This is done
         * automatically when executing DragDrop.setHandleElId()
         * @method regHandle
         * @param {String} sDDId the DragDrop id this element is a handle for
         * @param {String} sHandleId the id of the element that is the drag 
         * handle
         * @static
         */
        regHandle: function(sDDId, sHandleId) {
            if (!this.handleIds[sDDId]) {
                this.handleIds[sDDId] = {};
            }
            this.handleIds[sDDId][sHandleId] = sHandleId;
        },

        /**
         * Utility function to determine if a given element has been 
         * registered as a drag drop item.
         * @method isDragDrop
         * @param {String} id the element id to check
         * @return {boolean} true if this element is a DragDrop item, 
         * false otherwise
         * @static
         */
        isDragDrop: function(id) {
            return ( this.getDDById(id) ) ? true : false;
        },

        /**
         * Returns the drag and drop instances that are in all groups the
         * passed in instance belongs to.
         * @method getRelated
         * @param {DragDrop} p_oDD the obj to get related data for
         * @param {boolean} bTargetsOnly if true, only return targetable objs
         * @return {DragDrop[]} the related instances
         * @static
         */
        getRelated: function(p_oDD, bTargetsOnly) {
            var oDDs = [];
            for (var i in p_oDD.groups) {
                for (var j in this.ids[i]) {
                    var dd = this.ids[i][j];
                    if (! this.isTypeOfDD(dd)) {
                        continue;
                    }
                    if (!bTargetsOnly || dd.isTarget) {
                        oDDs[oDDs.length] = dd;
                    }
                }
            }

            return oDDs;
        },

        /**
         * Returns true if the specified dd target is a legal target for 
         * the specifice drag obj
         * @method isLegalTarget
         * @param {DragDrop} the drag obj
         * @param {DragDrop} the target
         * @return {boolean} true if the target is a legal target for the 
         * dd obj
         * @static
         */
        isLegalTarget: function (oDD, oTargetDD) {
            var targets = this.getRelated(oDD, true);
            for (var i=0, len=targets.length;i<len;++i) {
                if (targets[i].id == oTargetDD.id) {
                    return true;
                }
            }

            return false;
        },

        /**
         * My goal is to be able to transparently determine if an object is
         * typeof DragDrop, and the exact subclass of DragDrop.  typeof 
         * returns "object", oDD.constructor.toString() always returns
         * "DragDrop" and not the name of the subclass.  So for now it just
         * evaluates a well-known variable in DragDrop.
         * @method isTypeOfDD
         * @param {Object} the object to evaluate
         * @return {boolean} true if typeof oDD = DragDrop
         * @static
         */
        isTypeOfDD: function (oDD) {
            return (oDD && oDD.__ygDragDrop);
        },

        /**
         * Utility function to determine if a given element has been 
         * registered as a drag drop handle for the given Drag Drop object.
         * @method isHandle
         * @param {String} id the element id to check
         * @return {boolean} true if this element is a DragDrop handle, false 
         * otherwise
         * @static
         */
        isHandle: function(sDDId, sHandleId) {
            return ( this.handleIds[sDDId] && 
                            this.handleIds[sDDId][sHandleId] );
        },

        /**
         * Returns the DragDrop instance for a given id
         * @method getDDById
         * @param {String} id the id of the DragDrop object
         * @return {DragDrop} the drag drop object, null if it is not found
         * @static
         */
        getDDById: function(id) {
            for (var i in this.ids) {
                if (this.ids[i][id]) {
                    return this.ids[i][id];
                }
            }
            return null;
        },

        /**
         * Fired after a registered DragDrop object gets the mousedown event.
         * Sets up the events required to track the object being dragged
         * @method handleMouseDown
         * @param {Event} e the event
         * @param oDD the DragDrop object being dragged
         * @private
         * @static
         */
        handleMouseDown: function(e, oDD) {
            //this._activateShim();

            this.currentTarget = YAHOO.util.Event.getTarget(e);

            this.dragCurrent = oDD;

            var el = oDD.getEl();

            // track start position
            this.startX = YAHOO.util.Event.getPageX(e);
            this.startY = YAHOO.util.Event.getPageY(e);

            this.deltaX = this.startX - el.offsetLeft;
            this.deltaY = this.startY - el.offsetTop;

            this.dragThreshMet = false;

            this.clickTimeout = setTimeout( 
                    function() { 
                        var DDM = YAHOO.util.DDM;
                        DDM.startDrag(DDM.startX, DDM.startY);
                        DDM.fromTimeout = true;
                    }, 
                    this.clickTimeThresh );
        },

        /**
         * Fired when either the drag pixel threshold or the mousedown hold 
         * time threshold has been met.
         * @method startDrag
         * @param x {int} the X position of the original mousedown
         * @param y {int} the Y position of the original mousedown
         * @static
         */
        startDrag: function(x, y) {
            if (this.dragCurrent && this.dragCurrent.useShim) {
                this._shimState = this.useShim;
                this.useShim = true;
            }
            this._activateShim();
            clearTimeout(this.clickTimeout);
            var dc = this.dragCurrent;
            if (dc && dc.events.b4StartDrag) {
                dc.b4StartDrag(x, y);
                dc.fireEvent('b4StartDragEvent', { x: x, y: y });
            }
            if (dc && dc.events.startDrag) {
                dc.startDrag(x, y);
                dc.fireEvent('startDragEvent', { x: x, y: y });
            }
            this.dragThreshMet = true;
        },

        /**
         * Internal function to handle the mouseup event.  Will be invoked 
         * from the context of the document.
         * @method handleMouseUp
         * @param {Event} e the event
         * @private
         * @static
         */
        handleMouseUp: function(e) {
            if (this.dragCurrent) {
                clearTimeout(this.clickTimeout);

                if (this.dragThreshMet) {
                    if (this.fromTimeout) {
                        this.fromTimeout = false;
                        this.handleMouseMove(e);
                    }
                    this.fromTimeout = false;
                    this.fireEvents(e, true);
                } else {
                }

                this.stopDrag(e);

                this.stopEvent(e);
            }
        },

        /**
         * Utility to stop event propagation and event default, if these 
         * features are turned on.
         * @method stopEvent
         * @param {Event} e the event as returned by this.getEvent()
         * @static
         */
        stopEvent: function(e) {
            if (this.stopPropagation) {
                YAHOO.util.Event.stopPropagation(e);
            }

            if (this.preventDefault) {
                YAHOO.util.Event.preventDefault(e);
            }
        },

        /** 
         * Ends the current drag, cleans up the state, and fires the endDrag
         * and mouseUp events.  Called internally when a mouseup is detected
         * during the drag.  Can be fired manually during the drag by passing
         * either another event (such as the mousemove event received in onDrag)
         * or a fake event with pageX and pageY defined (so that endDrag and
         * onMouseUp have usable position data.).  Alternatively, pass true
         * for the silent parameter so that the endDrag and onMouseUp events
         * are skipped (so no event data is needed.)
         *
         * @method stopDrag
         * @param {Event} e the mouseup event, another event (or a fake event) 
         *                  with pageX and pageY defined, or nothing if the 
         *                  silent parameter is true
         * @param {boolean} silent skips the enddrag and mouseup events if true
         * @static
         */
        stopDrag: function(e, silent) {
            var dc = this.dragCurrent;
            // Fire the drag end event for the item that was dragged
            if (dc && !silent) {
                if (this.dragThreshMet) {
                    if (dc.events.b4EndDrag) {
                        dc.b4EndDrag(e);
                        dc.fireEvent('b4EndDragEvent', { e: e });
                    }
                    if (dc.events.endDrag) {
                        dc.endDrag(e);
                        dc.fireEvent('endDragEvent', { e: e });
                    }
                }
                if (dc.events.mouseUp) {
                    dc.onMouseUp(e);
                    dc.fireEvent('mouseUpEvent', { e: e });
                }
            }

            if (this._shimActive) {
                this._deactivateShim();
                if (this.dragCurrent && this.dragCurrent.useShim) {
                    this.useShim = this._shimState;
                    this._shimState = false;
                }
            }

            this.dragCurrent = null;
            this.dragOvers = {};
        },

        /** 
         * Internal function to handle the mousemove event.  Will be invoked 
         * from the context of the html element.
         *
         * @TODO figure out what we can do about mouse events lost when the 
         * user drags objects beyond the window boundary.  Currently we can 
         * detect this in internet explorer by verifying that the mouse is 
         * down during the mousemove event.  Firefox doesn't give us the 
         * button state on the mousemove event.
         * @method handleMouseMove
         * @param {Event} e the event
         * @private
         * @static
         */
        handleMouseMove: function(e) {

            var dc = this.dragCurrent;
            if (dc) {

                // var button = e.which || e.button;

                // check for IE < 9 mouseup outside of page boundary
                if (YAHOO.env.ua.ie && (YAHOO.env.ua.ie < 9) && !e.button) {
                    this.stopEvent(e);
                    return this.handleMouseUp(e);
                } else {
                    if (e.clientX < 0 || e.clientY < 0) {
                        //This will stop the element from leaving the viewport in FF, Opera & Safari
                        //Not turned on yet
                        //this.stopEvent(e);
                        //return false;
                    }
                }

                if (!this.dragThreshMet) {
                    var diffX = Math.abs(this.startX - YAHOO.util.Event.getPageX(e));
                    var diffY = Math.abs(this.startY - YAHOO.util.Event.getPageY(e));
                    if (diffX > this.clickPixelThresh || 
                                diffY > this.clickPixelThresh) {
                        this.startDrag(this.startX, this.startY);
                    }
                }

                if (this.dragThreshMet) {
                    if (dc && dc.events.b4Drag) {
                        dc.b4Drag(e);
                        dc.fireEvent('b4DragEvent', { e: e});
                    }
                    if (dc && dc.events.drag) {
                        dc.onDrag(e);
                        dc.fireEvent('dragEvent', { e: e});
                    }
                    if (dc) {
                        this.fireEvents(e, false);
                    }
                }

                this.stopEvent(e);
            }
        },
        
        /**
         * Iterates over all of the DragDrop elements to find ones we are 
         * hovering over or dropping on
         * @method fireEvents
         * @param {Event} e the event
         * @param {boolean} isDrop is this a drop op or a mouseover op?
         * @private
         * @static
         */
        fireEvents: function(e, isDrop) {
            var dc = this.dragCurrent;

            // If the user did the mouse up outside of the window, we could 
            // get here even though we have ended the drag.
            // If the config option dragOnly is true, bail out and don't fire the events
            if (!dc || dc.isLocked() || dc.dragOnly) {
                return;
            }

            var x = YAHOO.util.Event.getPageX(e),
                y = YAHOO.util.Event.getPageY(e),
                pt = new YAHOO.util.Point(x,y),
                pos = dc.getTargetCoord(pt.x, pt.y),
                el = dc.getDragEl(),
                events = ['out', 'over', 'drop', 'enter'],
                curRegion = new YAHOO.util.Region( pos.y, 
                                               pos.x + el.offsetWidth,
                                               pos.y + el.offsetHeight, 
                                               pos.x ),
            
                oldOvers = [], // cache the previous dragOver array
                inGroupsObj  = {},
                inGroups  = [],
                data = {
                    outEvts: [],
                    overEvts: [],
                    dropEvts: [],
                    enterEvts: []
                };


            // Check to see if the object(s) we were hovering over is no longer 
            // being hovered over so we can fire the onDragOut event
            for (var i in this.dragOvers) {

                var ddo = this.dragOvers[i];

                if (! this.isTypeOfDD(ddo)) {
                    continue;
                }
                if (! this.isOverTarget(pt, ddo, this.mode, curRegion)) {
                    data.outEvts.push( ddo );
                }

                oldOvers[i] = true;
                delete this.dragOvers[i];
            }

            for (var sGroup in dc.groups) {
                
                if ("string" != typeof sGroup) {
                    continue;
                }

                for (i in this.ids[sGroup]) {
                    var oDD = this.ids[sGroup][i];
                    if (! this.isTypeOfDD(oDD)) {
                        continue;
                    }

                    if (oDD.isTarget && !oDD.isLocked() && oDD != dc) {
                        if (this.isOverTarget(pt, oDD, this.mode, curRegion)) {
                            inGroupsObj[sGroup] = true;
                            // look for drop interactions
                            if (isDrop) {
                                data.dropEvts.push( oDD );
                            // look for drag enter and drag over interactions
                            } else {

                                // initial drag over: dragEnter fires
                                if (!oldOvers[oDD.id]) {
                                    data.enterEvts.push( oDD );
                                // subsequent drag overs: dragOver fires
                                } else {
                                    data.overEvts.push( oDD );
                                }

                                this.dragOvers[oDD.id] = oDD;
                            }
                        }
                    }
                }
            }

            this.interactionInfo = {
                out:       data.outEvts,
                enter:     data.enterEvts,
                over:      data.overEvts,
                drop:      data.dropEvts,
                point:     pt,
                draggedRegion:    curRegion,
                sourceRegion: this.locationCache[dc.id],
                validDrop: isDrop
            };

            
            for (var inG in inGroupsObj) {
                inGroups.push(inG);
            }

            // notify about a drop that did not find a target
            if (isDrop && !data.dropEvts.length) {
                this.interactionInfo.validDrop = false;
                if (dc.events.invalidDrop) {
                    dc.onInvalidDrop(e);
                    dc.fireEvent('invalidDropEvent', { e: e });
                }
            }
            for (i = 0; i < events.length; i++) {
                var tmp = null;
                if (data[events[i] + 'Evts']) {
                    tmp = data[events[i] + 'Evts'];
                }
                if (tmp && tmp.length) {
                    var type = events[i].charAt(0).toUpperCase() + events[i].substr(1),
                        ev = 'onDrag' + type,
                        b4 = 'b4Drag' + type,
                        cev = 'drag' + type + 'Event',
                        check = 'drag' + type;
                    if (this.mode) {
                        if (dc.events[b4]) {
                            dc[b4](e, tmp, inGroups);
                            dc.fireEvent(b4 + 'Event', { event: e, info: tmp, group: inGroups });
                            
                        }
                        if (dc.events[check]) {
                            dc[ev](e, tmp, inGroups);
                            dc.fireEvent(cev, { event: e, info: tmp, group: inGroups });
                        }
                    } else {
                        for (var b = 0, len = tmp.length; b < len; ++b) {
                            if (dc.events[b4]) {
                                dc[b4](e, tmp[b].id, inGroups[0]);
                                dc.fireEvent(b4 + 'Event', { event: e, info: tmp[b].id, group: inGroups[0] });
                            }
                            if (dc.events[check]) {
                                dc[ev](e, tmp[b].id, inGroups[0]);
                                dc.fireEvent(cev, { event: e, info: tmp[b].id, group: inGroups[0] });
                            }
                        }
                    }
                }
            }
        },

        /**
         * Helper function for getting the best match from the list of drag 
         * and drop objects returned by the drag and drop events when we are 
         * in INTERSECT mode.  It returns either the first object that the 
         * cursor is over, or the object that has the greatest overlap with 
         * the dragged element.
         * @method getBestMatch
         * @param  {DragDrop[]} dds The array of drag and drop objects 
         * targeted
         * @return {DragDrop}       The best single match
         * @static
         */
        getBestMatch: function(dds) {
            var winner = null;

            var len = dds.length;

            if (len == 1) {
                winner = dds[0];
            } else {
                // Loop through the targeted items
                for (var i=0; i<len; ++i) {
                    var dd = dds[i];
                    // If the cursor is over the object, it wins.  If the 
                    // cursor is over multiple matches, the first one we come
                    // to wins.
                    if (this.mode == this.INTERSECT && dd.cursorIsOver) {
                        winner = dd;
                        break;
                    // Otherwise the object with the most overlap wins
                    } else {
                        if (!winner || !winner.overlap || (dd.overlap &&
                            winner.overlap.getArea() < dd.overlap.getArea())) {
                            winner = dd;
                        }
                    }
                }
            }

            return winner;
        },

        /**
         * Refreshes the cache of the top-left and bottom-right points of the 
         * drag and drop objects in the specified group(s).  This is in the
         * format that is stored in the drag and drop instance, so typical 
         * usage is:
         * <code>
         * YAHOO.util.DragDropMgr.refreshCache(ddinstance.groups);
         * </code>
         * Alternatively:
         * <code>
         * YAHOO.util.DragDropMgr.refreshCache({group1:true, group2:true});
         * </code>
         * @TODO this really should be an indexed array.  Alternatively this
         * method could accept both.
         * @method refreshCache
         * @param {Object} groups an associative array of groups to refresh
         * @static
         */
        refreshCache: function(groups) {

            // refresh everything if group array is not provided
            var g = groups || this.ids;

            for (var sGroup in g) {
                if ("string" != typeof sGroup) {
                    continue;
                }
                for (var i in this.ids[sGroup]) {
                    var oDD = this.ids[sGroup][i];

                    if (this.isTypeOfDD(oDD)) {
                        var loc = this.getLocation(oDD);
                        if (loc) {
                            this.locationCache[oDD.id] = loc;
                        } else {
                            delete this.locationCache[oDD.id];
                        }
                    }
                }
            }
        },

        /**
         * This checks to make sure an element exists and is in the DOM.  The
         * main purpose is to handle cases where innerHTML is used to remove
         * drag and drop objects from the DOM.  IE provides an 'unspecified
         * error' when trying to access the offsetParent of such an element
         * @method verifyEl
         * @param {HTMLElement} el the element to check
         * @return {boolean} true if the element looks usable
         * @static
         */
        verifyEl: function(el) {
            try {
                if (el) {
                    var parent = el.offsetParent;
                    if (parent) {
                        return true;
                    }
                }
            } catch(e) {
            }

            return false;
        },
        
        /**
         * Returns a Region object containing the drag and drop element's position
         * and size, including the padding configured for it
         * @method getLocation
         * @param {DragDrop} oDD the drag and drop object to get the 
         *                       location for
         * @return {YAHOO.util.Region} a Region object representing the total area
         *                             the element occupies, including any padding
         *                             the instance is configured for.
         * @static
         */
        getLocation: function(oDD) {
            if (! this.isTypeOfDD(oDD)) {
                return null;
            }

            var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;

            try {
                pos= YAHOO.util.Dom.getXY(el);
            } catch (e) { }

            if (!pos) {
                return null;
            }

            x1 = pos[0];
            x2 = x1 + el.offsetWidth;
            y1 = pos[1];
            y2 = y1 + el.offsetHeight;

            t = y1 - oDD.padding[0];
            r = x2 + oDD.padding[1];
            b = y2 + oDD.padding[2];
            l = x1 - oDD.padding[3];

            return new YAHOO.util.Region( t, r, b, l );
        },

        /**
         * Checks the cursor location to see if it over the target
         * @method isOverTarget
         * @param {YAHOO.util.Point} pt The point to evaluate
         * @param {DragDrop} oTarget the DragDrop object we are inspecting
         * @param {boolean} intersect true if we are in intersect mode
         * @param {YAHOO.util.Region} pre-cached location of the dragged element
         * @return {boolean} true if the mouse is over the target
         * @private
         * @static
         */
        isOverTarget: function(pt, oTarget, intersect, curRegion) {
            // use cache if available
            var loc = this.locationCache[oTarget.id];
            if (!loc || !this.useCache) {
                loc = this.getLocation(oTarget);
                this.locationCache[oTarget.id] = loc;

            }

            if (!loc) {
                return false;
            }

            oTarget.cursorIsOver = loc.contains( pt );

            // DragDrop is using this as a sanity check for the initial mousedown
            // in this case we are done.  In POINT mode, if the drag obj has no
            // contraints, we are done. Otherwise we need to evaluate the 
            // region the target as occupies to determine if the dragged element
            // overlaps with it.
            
            var dc = this.dragCurrent;
            if (!dc || (!intersect && !dc.constrainX && !dc.constrainY)) {

                //if (oTarget.cursorIsOver) {
                //}
                return oTarget.cursorIsOver;
            }

            oTarget.overlap = null;


            // Get the current location of the drag element, this is the
            // location of the mouse event less the delta that represents
            // where the original mousedown happened on the element.  We
            // need to consider constraints and ticks as well.

            if (!curRegion) {
                var pos = dc.getTargetCoord(pt.x, pt.y);
                var el = dc.getDragEl();
                curRegion = new YAHOO.util.Region( pos.y, 
                                                   pos.x + el.offsetWidth,
                                                   pos.y + el.offsetHeight, 
                                                   pos.x );
            }

            var overlap = curRegion.intersect(loc);

            if (overlap) {
                oTarget.overlap = overlap;
                return (intersect) ? true : oTarget.cursorIsOver;
            } else {
                return false;
            }
        },

        /**
         * unload event handler
         * @method _onUnload
         * @private
         * @static
         */
        _onUnload: function(e, me) {
            this.unregAll();
        },

        /**
         * Cleans up the drag and drop events and objects.
         * @method unregAll
         * @private
         * @static
         */
        unregAll: function() {

            if (this.dragCurrent) {
                this.stopDrag();
                this.dragCurrent = null;
            }

            this._execOnAll("unreg", []);

            //for (var i in this.elementCache) {
                //delete this.elementCache[i];
            //}
            //this.elementCache = {};

            this.ids = {};
        },

        /**
         * A cache of DOM elements
         * @property elementCache
         * @private
         * @static
         * @deprecated elements are not cached now
         */
        elementCache: {},
        
        /**
         * Get the wrapper for the DOM element specified
         * @method getElWrapper
         * @param {String} id the id of the element to get
         * @return {YAHOO.util.DDM.ElementWrapper} the wrapped element
         * @private
         * @deprecated This wrapper isn't that useful
         * @static
         */
        getElWrapper: function(id) {
            var oWrapper = this.elementCache[id];
            if (!oWrapper || !oWrapper.el) {
                oWrapper = this.elementCache[id] = 
                    new this.ElementWrapper(YAHOO.util.Dom.get(id));
            }
            return oWrapper;
        },

        /**
         * Returns the actual DOM element
         * @method getElement
         * @param {String} id the id of the elment to get
         * @return {Object} The element
         * @deprecated use YAHOO.util.Dom.get instead
         * @static
         */
        getElement: function(id) {
            return YAHOO.util.Dom.get(id);
        },
        
        /**
         * Returns the style property for the DOM element (i.e., 
         * document.getElById(id).style)
         * @method getCss
         * @param {String} id the id of the elment to get
         * @return {Object} The style property of the element
         * @deprecated use YAHOO.util.Dom instead
         * @static
         */
        getCss: function(id) {
            var el = YAHOO.util.Dom.get(id);
            return (el) ? el.style : null;
        },

        /**
         * Inner class for cached elements
         * @class DragDropMgr.ElementWrapper
         * @for DragDropMgr
         * @private
         * @deprecated
         */
        ElementWrapper: function(el) {
                /**
                 * The element
                 * @property el
                 */
                this.el = el || null;
                /**
                 * The element id
                 * @property id
                 */
                this.id = this.el && el.id;
                /**
                 * A reference to the style property
                 * @property css
                 */
                this.css = this.el && el.style;
            },

        /**
         * Returns the X position of an html element
         * @method getPosX
         * @param el the element for which to get the position
         * @return {int} the X coordinate
         * @for DragDropMgr
         * @deprecated use YAHOO.util.Dom.getX instead
         * @static
         */
        getPosX: function(el) {
            return YAHOO.util.Dom.getX(el);
        },

        /**
         * Returns the Y position of an html element
         * @method getPosY
         * @param el the element for which to get the position
         * @return {int} the Y coordinate
         * @deprecated use YAHOO.util.Dom.getY instead
         * @static
         */
        getPosY: function(el) {
            return YAHOO.util.Dom.getY(el); 
        },

        /**
         * Swap two nodes.  In IE, we use the native method, for others we 
         * emulate the IE behavior
         * @method swapNode
         * @param n1 the first node to swap
         * @param n2 the other node to swap
         * @static
         */
        swapNode: function(n1, n2) {
            if (n1.swapNode) {
                n1.swapNode(n2);
            } else {
                var p = n2.parentNode;
                var s = n2.nextSibling;

                if (s == n1) {
                    p.insertBefore(n1, n2);
                } else if (n2 == n1.nextSibling) {
                    p.insertBefore(n2, n1);
                } else {
                    n1.parentNode.replaceChild(n2, n1);
                    p.insertBefore(n1, s);
                }
            }
        },

        /**
         * Returns the current scroll position
         * @method getScroll
         * @private
         * @static
         */
        getScroll: function () {
            var t, l, dde=document.documentElement, db=document.body;
            if (dde && (dde.scrollTop || dde.scrollLeft)) {
                t = dde.scrollTop;
                l = dde.scrollLeft;
            } else if (db) {
                t = db.scrollTop;
                l = db.scrollLeft;
            } else {
            }
            return { top: t, left: l };
        },

        /**
         * Returns the specified element style property
         * @method getStyle
         * @param {HTMLElement} el          the element
         * @param {string}      styleProp   the style property
         * @return {string} The value of the style property
         * @deprecated use YAHOO.util.Dom.getStyle
         * @static
         */
        getStyle: function(el, styleProp) {
            return YAHOO.util.Dom.getStyle(el, styleProp);
        },

        /**
         * Gets the scrollTop
         * @method getScrollTop
         * @return {int} the document's scrollTop
         * @static
         */
        getScrollTop: function () { return this.getScroll().top; },

        /**
         * Gets the scrollLeft
         * @method getScrollLeft
         * @return {int} the document's scrollTop
         * @static
         */
        getScrollLeft: function () { return this.getScroll().left; },

        /**
         * Sets the x/y position of an element to the location of the
         * target element.
         * @method moveToEl
         * @param {HTMLElement} moveEl      The element to move
         * @param {HTMLElement} targetEl    The position reference element
         * @static
         */
        moveToEl: function (moveEl, targetEl) {
            var aCoord = YAHOO.util.Dom.getXY(targetEl);
            YAHOO.util.Dom.setXY(moveEl, aCoord);
        },

        /**
         * Gets the client height
         * @method getClientHeight
         * @return {int} client height in px
         * @deprecated use YAHOO.util.Dom.getViewportHeight instead
         * @static
         */
        getClientHeight: function() {
            return YAHOO.util.Dom.getViewportHeight();
        },

        /**
         * Gets the client width
         * @method getClientWidth
         * @return {int} client width in px
         * @deprecated use YAHOO.util.Dom.getViewportWidth instead
         * @static
         */
        getClientWidth: function() {
            return YAHOO.util.Dom.getViewportWidth();
        },

        /**
         * Numeric array sort function
         * @method numericSort
         * @static
         */
        numericSort: function(a, b) { return (a - b); },

        /**
         * Internal counter
         * @property _timeoutCount
         * @private
         * @static
         */
        _timeoutCount: 0,

        /**
         * Trying to make the load order less important.  Without this we get
         * an error if this file is loaded before the Event Utility.
         * @method _addListeners
         * @private
         * @static
         */
        _addListeners: function() {
            var DDM = YAHOO.util.DDM;
            if ( YAHOO.util.Event && document ) {
                DDM._onLoad();
            } else {
                if (DDM._timeoutCount > 2000) {
                } else {
                    setTimeout(DDM._addListeners, 10);
                    if (document && document.body) {
                        DDM._timeoutCount += 1;
                    }
                }
            }
        },

        /**
         * Recursively searches the immediate parent and all child nodes for 
         * the handle element in order to determine wheter or not it was 
         * clicked.
         * @method handleWasClicked
         * @param node the html element to inspect
         * @static
         */
        handleWasClicked: function(node, id) {
            if (this.isHandle(id, node.id)) {
                return true;
            } else {
                // check to see if this is a text node child of the one we want
                var p = node.parentNode;

                while (p) {
                    if (this.isHandle(id, p.id)) {
                        return true;
                    } else {
                        p = p.parentNode;
                    }
                }
            }

            return false;
        }

    };

}();

// shorter alias, save a few bytes
YAHOO.util.DDM = YAHOO.util.DragDropMgr;
YAHOO.util.DDM._addListeners();

}

(function() {

var Event=YAHOO.util.Event; 
var Dom=YAHOO.util.Dom;

/**
 * Defines the interface and base operation of items that that can be 
 * dragged or can be drop targets.  It was designed to be extended, overriding
 * the event handlers for startDrag, onDrag, onDragOver, onDragOut.
 * Up to three html elements can be associated with a DragDrop instance:
 * <ul>
 * <li>linked element: the element that is passed into the constructor.
 * This is the element which defines the boundaries for interaction with 
 * other DragDrop objects.</li>
 * <li>handle element(s): The drag operation only occurs if the element that 
 * was clicked matches a handle element.  By default this is the linked 
 * element, but there are times that you will want only a portion of the 
 * linked element to initiate the drag operation, and the setHandleElId() 
 * method provides a way to define this.</li>
 * <li>drag element: this represents an the element that would be moved along
 * with the cursor during a drag operation.  By default, this is the linked
 * element itself as in {@link YAHOO.util.DD}.  setDragElId() lets you define
 * a separate element that would be moved, as in {@link YAHOO.util.DDProxy}
 * </li>
 * </ul>
 * This class should not be instantiated until the onload event to ensure that
 * the associated elements are available.
 * The following would define a DragDrop obj that would interact with any 
 * other DragDrop obj in the "group1" group:
 * <pre>
 *  dd = new YAHOO.util.DragDrop("div1", "group1");
 * </pre>
 * Since none of the event handlers have been implemented, nothing would 
 * actually happen if you were to run the code above.  Normally you would 
 * override this class or one of the default implementations, but you can 
 * also override the methods you want on an instance of the class...
 * <pre>
 *  dd.onDragDrop = function(e, id) {
 *  &nbsp;&nbsp;alert("dd was dropped on " + id);
 *  }
 * </pre>
 * @namespace YAHOO.util
 * @class DragDrop
 * @constructor
 * @param {String} id of the element that is linked to this instance
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DragDrop: 
 *                    padding, isTarget, maintainOffset, primaryButtonOnly,
 */
YAHOO.util.DragDrop = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config); 
    }
};

YAHOO.util.DragDrop.prototype = {
    /**
     * An Object Literal containing the events that we will be using: mouseDown, b4MouseDown, mouseUp, b4StartDrag, startDrag, b4EndDrag, endDrag, mouseUp, drag, b4Drag, invalidDrop, b4DragOut, dragOut, dragEnter, b4DragOver, dragOver, b4DragDrop, dragDrop
     * By setting any of these to false, then event will not be fired.
     * @property events
     * @type object
     */
    events: null,
    /**
    * @method on
    * @description Shortcut for EventProvider.subscribe, see <a href="YAHOO.util.EventProvider.html#subscribe">YAHOO.util.EventProvider.subscribe</a>
    */
    on: function() {
        this.subscribe.apply(this, arguments);
    },
    /**
     * The id of the element associated with this object.  This is what we 
     * refer to as the "linked element" because the size and position of 
     * this element is used to determine when the drag and drop objects have 
     * interacted.
     * @property id
     * @type String
     */
    id: null,

    /**
     * Configuration attributes passed into the constructor
     * @property config
     * @type object
     */
    config: null,

    /**
     * The id of the element that will be dragged.  By default this is same 
     * as the linked element , but could be changed to another element. Ex: 
     * YAHOO.util.DDProxy
     * @property dragElId
     * @type String
     * @private
     */
    dragElId: null, 

    /**
     * the id of the element that initiates the drag operation.  By default 
     * this is the linked element, but could be changed to be a child of this
     * element.  This lets us do things like only starting the drag when the 
     * header element within the linked html element is clicked.
     * @property handleElId
     * @type String
     * @private
     */
    handleElId: null, 

    /**
     * An associative array of HTML tags that will be ignored if clicked.
     * @property invalidHandleTypes
     * @type {string: string}
     */
    invalidHandleTypes: null, 

    /**
     * An associative array of ids for elements that will be ignored if clicked
     * @property invalidHandleIds
     * @type {string: string}
     */
    invalidHandleIds: null, 

    /**
     * An indexted array of css class names for elements that will be ignored
     * if clicked.
     * @property invalidHandleClasses
     * @type string[]
     */
    invalidHandleClasses: null, 

    /**
     * The linked element's absolute X position at the time the drag was 
     * started
     * @property startPageX
     * @type int
     * @private
     */
    startPageX: 0,

    /**
     * The linked element's absolute X position at the time the drag was 
     * started
     * @property startPageY
     * @type int
     * @private
     */
    startPageY: 0,

    /**
     * The group defines a logical collection of DragDrop objects that are 
     * related.  Instances only get events when interacting with other 
     * DragDrop object in the same group.  This lets us define multiple 
     * groups using a single DragDrop subclass if we want.
     * @property groups
     * @type {string: string}
     */
    groups: null,

    /**
     * Individual drag/drop instances can be locked.  This will prevent 
     * onmousedown start drag.
     * @property locked
     * @type boolean
     * @private
     */
    locked: false,

    /**
     * Lock this instance
     * @method lock
     */
    lock: function() { this.locked = true; },

    /**
     * Unlock this instace
     * @method unlock
     */
    unlock: function() { this.locked = false; },

    /**
     * By default, all instances can be a drop target.  This can be disabled by
     * setting isTarget to false.
     * @property isTarget
     * @type boolean
     */
    isTarget: true,

    /**
     * The padding configured for this drag and drop object for calculating
     * the drop zone intersection with this object.
     * @property padding
     * @type int[]
     */
    padding: null,
    /**
     * If this flag is true, do not fire drop events. The element is a drag only element (for movement not dropping)
     * @property dragOnly
     * @type Boolean
     */
    dragOnly: false,

    /**
     * If this flag is true, a shim will be placed over the screen/viewable area to track mouse events. Should help with dragging elements over iframes and other controls.
     * @property useShim
     * @type Boolean
     */
    useShim: false,

    /**
     * Cached reference to the linked element
     * @property _domRef
     * @private
     */
    _domRef: null,

    /**
     * Internal typeof flag
     * @property __ygDragDrop
     * @private
     */
    __ygDragDrop: true,

    /**
     * Set to true when horizontal contraints are applied
     * @property constrainX
     * @type boolean
     * @private
     */
    constrainX: false,

    /**
     * Set to true when vertical contraints are applied
     * @property constrainY
     * @type boolean
     * @private
     */
    constrainY: false,

    /**
     * The left constraint
     * @property minX
     * @type int
     * @private
     */
    minX: 0,

    /**
     * The right constraint
     * @property maxX
     * @type int
     * @private
     */
    maxX: 0,

    /**
     * The up constraint 
     * @property minY
     * @type int
     * @type int
     * @private
     */
    minY: 0,

    /**
     * The down constraint 
     * @property maxY
     * @type int
     * @private
     */
    maxY: 0,

    /**
     * The difference between the click position and the source element's location
     * @property deltaX
     * @type int
     * @private
     */
    deltaX: 0,

    /**
     * The difference between the click position and the source element's location
     * @property deltaY
     * @type int
     * @private
     */
    deltaY: 0,

    /**
     * Maintain offsets when we resetconstraints.  Set to true when you want
     * the position of the element relative to its parent to stay the same
     * when the page changes
     *
     * @property maintainOffset
     * @type boolean
     */
    maintainOffset: false,

    /**
     * Array of pixel locations the element will snap to if we specified a 
     * horizontal graduation/interval.  This array is generated automatically
     * when you define a tick interval.
     * @property xTicks
     * @type int[]
     */
    xTicks: null,

    /**
     * Array of pixel locations the element will snap to if we specified a 
     * vertical graduation/interval.  This array is generated automatically 
     * when you define a tick interval.
     * @property yTicks
     * @type int[]
     */
    yTicks: null,

    /**
     * By default the drag and drop instance will only respond to the primary
     * button click (left button for a right-handed mouse).  Set to true to
     * allow drag and drop to start with any mouse click that is propogated
     * by the browser
     * @property primaryButtonOnly
     * @type boolean
     */
    primaryButtonOnly: true,

    /**
     * The availabe property is false until the linked dom element is accessible.
     * @property available
     * @type boolean
     */
    available: false,

    /**
     * By default, drags can only be initiated if the mousedown occurs in the
     * region the linked element is.  This is done in part to work around a
     * bug in some browsers that mis-report the mousedown if the previous
     * mouseup happened outside of the window.  This property is set to true
     * if outer handles are defined.
     *
     * @property hasOuterHandles
     * @type boolean
     * @default false
     */
    hasOuterHandles: false,

    /**
     * Property that is assigned to a drag and drop object when testing to
     * see if it is being targeted by another dd object.  This property
     * can be used in intersect mode to help determine the focus of
     * the mouse interaction.  DDM.getBestMatch uses this property first to
     * determine the closest match in INTERSECT mode when multiple targets
     * are part of the same interaction.
     * @property cursorIsOver
     * @type boolean
     */
    cursorIsOver: false,

    /**
     * Property that is assigned to a drag and drop object when testing to
     * see if it is being targeted by another dd object.  This is a region
     * that represents the area the draggable element overlaps this target.
     * DDM.getBestMatch uses this property to compare the size of the overlap
     * to that of other targets in order to determine the closest match in
     * INTERSECT mode when multiple targets are part of the same interaction.
     * @property overlap 
     * @type YAHOO.util.Region
     */
    overlap: null,

    /**
     * Code that executes immediately before the startDrag event
     * @method b4StartDrag
     * @private
     */
    b4StartDrag: function(x, y) { },

    /**
     * Abstract method called after a drag/drop object is clicked
     * and the drag or mousedown time thresholds have beeen met.
     * @method startDrag
     * @param {int} X click location
     * @param {int} Y click location
     */
    startDrag: function(x, y) { /* override this */ },

    /**
     * Code that executes immediately before the onDrag event
     * @method b4Drag
     * @private
     */
    b4Drag: function(e) { },

    /**
     * Abstract method called during the onMouseMove event while dragging an 
     * object.
     * @method onDrag
     * @param {Event} e the mousemove event
     */
    onDrag: function(e) { /* override this */ },

    /**
     * Abstract method called when this element fist begins hovering over 
     * another DragDrop obj
     * @method onDragEnter
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of one or more 
     * dragdrop items being hovered over.
     */
    onDragEnter: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragOver event
     * @method b4DragOver
     * @private
     */
    b4DragOver: function(e) { },

    /**
     * Abstract method called when this element is hovering over another 
     * DragDrop obj
     * @method onDragOver
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of dd items 
     * being hovered over.
     */
    onDragOver: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragOut event
     * @method b4DragOut
     * @private
     */
    b4DragOut: function(e) { },

    /**
     * Abstract method called when we are no longer hovering over an element
     * @method onDragOut
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was hovering over.  In INTERSECT mode, an array of dd items 
     * that the mouse is no longer over.
     */
    onDragOut: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragDrop event
     * @method b4DragDrop
     * @private
     */
    b4DragDrop: function(e) { },

    /**
     * Abstract method called when this item is dropped on another DragDrop 
     * obj
     * @method onDragDrop
     * @param {Event} e the mouseup event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was dropped on.  In INTERSECT mode, an array of dd items this 
     * was dropped on.
     */
    onDragDrop: function(e, id) { /* override this */ },

    /**
     * Abstract method called when this item is dropped on an area with no
     * drop target
     * @method onInvalidDrop
     * @param {Event} e the mouseup event
     */
    onInvalidDrop: function(e) { /* override this */ },

    /**
     * Code that executes immediately before the endDrag event
     * @method b4EndDrag
     * @private
     */
    b4EndDrag: function(e) { },

    /**
     * Fired when we are done dragging the object
     * @method endDrag
     * @param {Event} e the mouseup event
     */
    endDrag: function(e) { /* override this */ },

    /**
     * Code executed immediately before the onMouseDown event
     * @method b4MouseDown
     * @param {Event} e the mousedown event
     * @private
     */
    b4MouseDown: function(e) {  },

    /**
     * Event handler that fires when a drag/drop obj gets a mousedown
     * @method onMouseDown
     * @param {Event} e the mousedown event
     */
    onMouseDown: function(e) { /* override this */ },

    /**
     * Event handler that fires when a drag/drop obj gets a mouseup
     * @method onMouseUp
     * @param {Event} e the mouseup event
     */
    onMouseUp: function(e) { /* override this */ },
   
    /**
     * Override the onAvailable method to do what is needed after the initial
     * position was determined.
     * @method onAvailable
     */
    onAvailable: function () { 
    },

    /**
     * Returns a reference to the linked element
     * @method getEl
     * @return {HTMLElement} the html element 
     */
    getEl: function() { 
        if (!this._domRef) {
            this._domRef = Dom.get(this.id); 
        }

        return this._domRef;
    },

    /**
     * Returns a reference to the actual element to drag.  By default this is
     * the same as the html element, but it can be assigned to another 
     * element. An example of this can be found in YAHOO.util.DDProxy
     * @method getDragEl
     * @return {HTMLElement} the html element 
     */
    getDragEl: function() {
        return Dom.get(this.dragElId);
    },

    /**
     * Sets up the DragDrop object.  Must be called in the constructor of any
     * YAHOO.util.DragDrop subclass
     * @method init
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    init: function(id, sGroup, config) {
        this.initTarget(id, sGroup, config);
        Event.on(this._domRef || this.id, "mousedown", 
                        this.handleMouseDown, this, true);

        // Event.on(this.id, "selectstart", Event.preventDefault);
        for (var i in this.events) {
            this.createEvent(i + 'Event');
        }
        
    },

    /**
     * Initializes Targeting functionality only... the object does not
     * get a mousedown handler.
     * @method initTarget
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    initTarget: function(id, sGroup, config) {

        // configuration attributes 
        this.config = config || {};

        this.events = {};

        // create a local reference to the drag and drop manager
        this.DDM = YAHOO.util.DDM;

        // initialize the groups object
        this.groups = {};

        // assume that we have an element reference instead of an id if the
        // parameter is not a string
        if (typeof id !== "string") {
            this._domRef = id;
            id = Dom.generateId(id);
        }

        // set the id
        this.id = id;

        // add to an interaction group
        this.addToGroup((sGroup) ? sGroup : "default");

        // We don't want to register this as the handle with the manager
        // so we just set the id rather than calling the setter.
        this.handleElId = id;

        Event.onAvailable(id, this.handleOnAvailable, this, true);


        // the linked element is the element that gets dragged by default
        this.setDragElId(id); 

        // by default, clicked anchors will not start drag operations. 
        // @TODO what else should be here?  Probably form fields.
        this.invalidHandleTypes = { A: "A" };
        this.invalidHandleIds = {};
        this.invalidHandleClasses = [];

        this.applyConfig();
    },

    /**
     * Applies the configuration parameters that were passed into the constructor.
     * This is supposed to happen at each level through the inheritance chain.  So
     * a DDProxy implentation will execute apply config on DDProxy, DD, and 
     * DragDrop in order to get all of the parameters that are available in
     * each object.
     * @method applyConfig
     */
    applyConfig: function() {
        this.events = {
            mouseDown: true,
            b4MouseDown: true,
            mouseUp: true,
            b4StartDrag: true,
            startDrag: true,
            b4EndDrag: true,
            endDrag: true,
            drag: true,
            b4Drag: true,
            invalidDrop: true,
            b4DragOut: true,
            dragOut: true,
            dragEnter: true,
            b4DragOver: true,
            dragOver: true,
            b4DragDrop: true,
            dragDrop: true
        };
        
        if (this.config.events) {
            for (var i in this.config.events) {
                if (this.config.events[i] === false) {
                    this.events[i] = false;
                }
            }
        }


        // configurable properties: 
        //    padding, isTarget, maintainOffset, primaryButtonOnly
        this.padding           = this.config.padding || [0, 0, 0, 0];
        this.isTarget          = (this.config.isTarget !== false);
        this.maintainOffset    = (this.config.maintainOffset);
        this.primaryButtonOnly = (this.config.primaryButtonOnly !== false);
        this.dragOnly = ((this.config.dragOnly === true) ? true : false);
        this.useShim = ((this.config.useShim === true) ? true : false);
    },

    /**
     * Executed when the linked element is available
     * @method handleOnAvailable
     * @private
     */
    handleOnAvailable: function() {
        this.available = true;
        this.resetConstraints();
        this.onAvailable();
    },

     /**
     * Configures the padding for the target zone in px.  Effectively expands
     * (or reduces) the virtual object size for targeting calculations.  
     * Supports css-style shorthand; if only one parameter is passed, all sides
     * will have that padding, and if only two are passed, the top and bottom
     * will have the first param, the left and right the second.
     * @method setPadding
     * @param {int} iTop    Top pad
     * @param {int} iRight  Right pad
     * @param {int} iBot    Bot pad
     * @param {int} iLeft   Left pad
     */
    setPadding: function(iTop, iRight, iBot, iLeft) {
        // this.padding = [iLeft, iRight, iTop, iBot];
        if (!iRight && 0 !== iRight) {
            this.padding = [iTop, iTop, iTop, iTop];
        } else if (!iBot && 0 !== iBot) {
            this.padding = [iTop, iRight, iTop, iRight];
        } else {
            this.padding = [iTop, iRight, iBot, iLeft];
        }
    },

    /**
     * Stores the initial placement of the linked element.
     * @method setInitialPosition
     * @param {int} diffX   the X offset, default 0
     * @param {int} diffY   the Y offset, default 0
     * @private
     */
    setInitPosition: function(diffX, diffY) {
        var el = this.getEl();

        if (!this.DDM.verifyEl(el)) {
            if (el && el.style && (el.style.display == 'none')) {
            } else {
            }
            return;
        }

        var dx = diffX || 0;
        var dy = diffY || 0;

        var p = Dom.getXY( el );

        this.initPageX = p[0] - dx;
        this.initPageY = p[1] - dy;

        this.lastPageX = p[0];
        this.lastPageY = p[1];



        this.setStartPosition(p);
    },

    /**
     * Sets the start position of the element.  This is set when the obj
     * is initialized, the reset when a drag is started.
     * @method setStartPosition
     * @param pos current position (from previous lookup)
     * @private
     */
    setStartPosition: function(pos) {
        var p = pos || Dom.getXY(this.getEl());

        this.deltaSetXY = null;

        this.startPageX = p[0];
        this.startPageY = p[1];
    },

    /**
     * Add this instance to a group of related drag/drop objects.  All 
     * instances belong to at least one group, and can belong to as many 
     * groups as needed.
     * @method addToGroup
     * @param sGroup {string} the name of the group
     */
    addToGroup: function(sGroup) {
        this.groups[sGroup] = true;
        this.DDM.regDragDrop(this, sGroup);
    },

    /**
     * Remove's this instance from the supplied interaction group
     * @method removeFromGroup
     * @param {string}  sGroup  The group to drop
     */
    removeFromGroup: function(sGroup) {
        if (this.groups[sGroup]) {
            delete this.groups[sGroup];
        }

        this.DDM.removeDDFromGroup(this, sGroup);
    },

    /**
     * Allows you to specify that an element other than the linked element 
     * will be moved with the cursor during a drag
     * @method setDragElId
     * @param id {string} the id of the element that will be used to initiate the drag
     */
    setDragElId: function(id) {
        this.dragElId = id;
    },

    /**
     * Allows you to specify a child of the linked element that should be 
     * used to initiate the drag operation.  An example of this would be if 
     * you have a content div with text and links.  Clicking anywhere in the 
     * content area would normally start the drag operation.  Use this method
     * to specify that an element inside of the content div is the element 
     * that starts the drag operation.
     * @method setHandleElId
     * @param id {string} the id of the element that will be used to 
     * initiate the drag.
     */
    setHandleElId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        this.handleElId = id;
        this.DDM.regHandle(this.id, id);
    },

    /**
     * Allows you to set an element outside of the linked element as a drag 
     * handle
     * @method setOuterHandleElId
     * @param id the id of the element that will be used to initiate the drag
     */
    setOuterHandleElId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        Event.on(id, "mousedown", 
                this.handleMouseDown, this, true);
        this.setHandleElId(id);

        this.hasOuterHandles = true;
    },

    /**
     * Remove all drag and drop hooks for this element
     * @method unreg
     */
    unreg: function() {
        Event.removeListener(this.id, "mousedown", 
                this.handleMouseDown);
        this._domRef = null;
        this.DDM._remove(this);
    },

    /**
     * Returns true if this instance is locked, or the drag drop mgr is locked
     * (meaning that all drag/drop is disabled on the page.)
     * @method isLocked
     * @return {boolean} true if this obj or all drag/drop is locked, else 
     * false
     */
    isLocked: function() {
        return (this.DDM.isLocked() || this.locked);
    },

    /**
     * Fired when this object is clicked
     * @method handleMouseDown
     * @param {Event} e 
     * @param {YAHOO.util.DragDrop} oDD the clicked dd object (this dd obj)
     * @private
     */
    handleMouseDown: function(e, oDD) {

        var button = e.which || e.button;

        if (this.primaryButtonOnly && button > 1) {
            return;
        }

        if (this.isLocked()) {
            return;
        }



        // firing the mousedown events prior to calculating positions
        var b4Return = this.b4MouseDown(e),
        b4Return2 = true;

        if (this.events.b4MouseDown) {
            b4Return2 = this.fireEvent('b4MouseDownEvent', e);
        }
        var mDownReturn = this.onMouseDown(e),
            mDownReturn2 = true;
        if (this.events.mouseDown) {
            mDownReturn2 = this.fireEvent('mouseDownEvent', e);
        }

        if ((b4Return === false) || (mDownReturn === false) || (b4Return2 === false) || (mDownReturn2 === false)) {
            return;
        }

        this.DDM.refreshCache(this.groups);
        // var self = this;
        // setTimeout( function() { self.DDM.refreshCache(self.groups); }, 0);

        // Only process the event if we really clicked within the linked 
        // element.  The reason we make this check is that in the case that 
        // another element was moved between the clicked element and the 
        // cursor in the time between the mousedown and mouseup events. When 
        // this happens, the element gets the next mousedown event 
        // regardless of where on the screen it happened.  
        var pt = new YAHOO.util.Point(Event.getPageX(e), Event.getPageY(e));
        if (!this.hasOuterHandles && !this.DDM.isOverTarget(pt, this) )  {
        } else {
            if (this.clickValidator(e)) {


                // set the initial element position
                this.setStartPosition();

                // start tracking mousemove distance and mousedown time to
                // determine when to start the actual drag
                this.DDM.handleMouseDown(e, this);

                // this mousedown is mine
                this.DDM.stopEvent(e);
            } else {


            }
        }
    },

    /**
     * @method clickValidator
     * @description Method validates that the clicked element
     * was indeed the handle or a valid child of the handle
     * @param {Event} e 
     */
    clickValidator: function(e) {
        var target = YAHOO.util.Event.getTarget(e);
        return ( this.isValidHandleChild(target) &&
                    (this.id == this.handleElId || 
                        this.DDM.handleWasClicked(target, this.id)) );
    },

    /**
     * Finds the location the element should be placed if we want to move
     * it to where the mouse location less the click offset would place us.
     * @method getTargetCoord
     * @param {int} iPageX the X coordinate of the click
     * @param {int} iPageY the Y coordinate of the click
     * @return an object that contains the coordinates (Object.x and Object.y)
     * @private
     */
    getTargetCoord: function(iPageX, iPageY) {


        var x = iPageX - this.deltaX;
        var y = iPageY - this.deltaY;

        if (this.constrainX) {
            if (x < this.minX) { x = this.minX; }
            if (x > this.maxX) { x = this.maxX; }
        }

        if (this.constrainY) {
            if (y < this.minY) { y = this.minY; }
            if (y > this.maxY) { y = this.maxY; }
        }

        x = this.getTick(x, this.xTicks);
        y = this.getTick(y, this.yTicks);


        return {x:x, y:y};
    },

    /**
     * Allows you to specify a tag name that should not start a drag operation
     * when clicked.  This is designed to facilitate embedding links within a
     * drag handle that do something other than start the drag.
     * @method addInvalidHandleType
     * @param {string} tagName the type of element to exclude
     */
    addInvalidHandleType: function(tagName) {
        var type = tagName.toUpperCase();
        this.invalidHandleTypes[type] = type;
    },

    /**
     * Lets you to specify an element id for a child of a drag handle
     * that should not initiate a drag
     * @method addInvalidHandleId
     * @param {string} id the element id of the element you wish to ignore
     */
    addInvalidHandleId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        this.invalidHandleIds[id] = id;
    },


    /**
     * Lets you specify a css class of elements that will not initiate a drag
     * @method addInvalidHandleClass
     * @param {string} cssClass the class of the elements you wish to ignore
     */
    addInvalidHandleClass: function(cssClass) {
        this.invalidHandleClasses.push(cssClass);
    },

    /**
     * Unsets an excluded tag name set by addInvalidHandleType
     * @method removeInvalidHandleType
     * @param {string} tagName the type of element to unexclude
     */
    removeInvalidHandleType: function(tagName) {
        var type = tagName.toUpperCase();
        // this.invalidHandleTypes[type] = null;
        delete this.invalidHandleTypes[type];
    },
    
    /**
     * Unsets an invalid handle id
     * @method removeInvalidHandleId
     * @param {string} id the id of the element to re-enable
     */
    removeInvalidHandleId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        delete this.invalidHandleIds[id];
    },

    /**
     * Unsets an invalid css class
     * @method removeInvalidHandleClass
     * @param {string} cssClass the class of the element(s) you wish to 
     * re-enable
     */
    removeInvalidHandleClass: function(cssClass) {
        for (var i=0, len=this.invalidHandleClasses.length; i<len; ++i) {
            if (this.invalidHandleClasses[i] == cssClass) {
                delete this.invalidHandleClasses[i];
            }
        }
    },

    /**
     * Checks the tag exclusion list to see if this click should be ignored
     * @method isValidHandleChild
     * @param {HTMLElement} node the HTMLElement to evaluate
     * @return {boolean} true if this is a valid tag type, false if not
     */
    isValidHandleChild: function(node) {

        var valid = true;
        // var n = (node.nodeName == "#text") ? node.parentNode : node;
        var nodeName;
        try {
            nodeName = node.nodeName.toUpperCase();
        } catch(e) {
            nodeName = node.nodeName;
        }
        valid = valid && !this.invalidHandleTypes[nodeName];
        valid = valid && !this.invalidHandleIds[node.id];

        for (var i=0, len=this.invalidHandleClasses.length; valid && i<len; ++i) {
            valid = !Dom.hasClass(node, this.invalidHandleClasses[i]);
        }


        return valid;

    },

    /**
     * Create the array of horizontal tick marks if an interval was specified
     * in setXConstraint().
     * @method setXTicks
     * @private
     */
    setXTicks: function(iStartX, iTickSize) {
        this.xTicks = [];
        this.xTickSize = iTickSize;
        
        var tickMap = {};

        for (var i = this.initPageX; i >= this.minX; i = i - iTickSize) {
            if (!tickMap[i]) {
                this.xTicks[this.xTicks.length] = i;
                tickMap[i] = true;
            }
        }

        for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) {
            if (!tickMap[i]) {
                this.xTicks[this.xTicks.length] = i;
                tickMap[i] = true;
            }
        }

        this.xTicks.sort(this.DDM.numericSort) ;
    },

    /**
     * Create the array of vertical tick marks if an interval was specified in 
     * setYConstraint().
     * @method setYTicks
     * @private
     */
    setYTicks: function(iStartY, iTickSize) {
        this.yTicks = [];
        this.yTickSize = iTickSize;

        var tickMap = {};

        for (var i = this.initPageY; i >= this.minY; i = i - iTickSize) {
            if (!tickMap[i]) {
                this.yTicks[this.yTicks.length] = i;
                tickMap[i] = true;
            }
        }

        for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) {
            if (!tickMap[i]) {
                this.yTicks[this.yTicks.length] = i;
                tickMap[i] = true;
            }
        }

        this.yTicks.sort(this.DDM.numericSort) ;
    },

    /**
     * By default, the element can be dragged any place on the screen.  Use 
     * this method to limit the horizontal travel of the element.  Pass in 
     * 0,0 for the parameters if you want to lock the drag to the y axis.
     * @method setXConstraint
     * @param {int} iLeft the number of pixels the element can move to the left
     * @param {int} iRight the number of pixels the element can move to the 
     * right
     * @param {int} iTickSize optional parameter for specifying that the 
     * element
     * should move iTickSize pixels at a time.
     */
    setXConstraint: function(iLeft, iRight, iTickSize) {
        this.leftConstraint = parseInt(iLeft, 10);
        this.rightConstraint = parseInt(iRight, 10);

        this.minX = this.initPageX - this.leftConstraint;
        this.maxX = this.initPageX + this.rightConstraint;
        if (iTickSize) { this.setXTicks(this.initPageX, iTickSize); }

        this.constrainX = true;
    },

    /**
     * Clears any constraints applied to this instance.  Also clears ticks
     * since they can't exist independent of a constraint at this time.
     * @method clearConstraints
     */
    clearConstraints: function() {
        this.constrainX = false;
        this.constrainY = false;
        this.clearTicks();
    },

    /**
     * Clears any tick interval defined for this instance
     * @method clearTicks
     */
    clearTicks: function() {
        this.xTicks = null;
        this.yTicks = null;
        this.xTickSize = 0;
        this.yTickSize = 0;
    },

    /**
     * By default, the element can be dragged any place on the screen.  Set 
     * this to limit the vertical travel of the element.  Pass in 0,0 for the
     * parameters if you want to lock the drag to the x axis.
     * @method setYConstraint
     * @param {int} iUp the number of pixels the element can move up
     * @param {int} iDown the number of pixels the element can move down
     * @param {int} iTickSize optional parameter for specifying that the 
     * element should move iTickSize pixels at a time.
     */
    setYConstraint: function(iUp, iDown, iTickSize) {
        this.topConstraint = parseInt(iUp, 10);
        this.bottomConstraint = parseInt(iDown, 10);

        this.minY = this.initPageY - this.topConstraint;
        this.maxY = this.initPageY + this.bottomConstraint;
        if (iTickSize) { this.setYTicks(this.initPageY, iTickSize); }

        this.constrainY = true;
        
    },

    /**
     * resetConstraints must be called if you manually reposition a dd element.
     * @method resetConstraints
     */
    resetConstraints: function() {


        // Maintain offsets if necessary
        if (this.initPageX || this.initPageX === 0) {
            // figure out how much this thing has moved
            var dx = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0;
            var dy = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0;

            this.setInitPosition(dx, dy);

        // This is the first time we have detected the element's position
        } else {
            this.setInitPosition();
        }

        if (this.constrainX) {
            this.setXConstraint( this.leftConstraint, 
                                 this.rightConstraint, 
                                 this.xTickSize        );
        }

        if (this.constrainY) {
            this.setYConstraint( this.topConstraint, 
                                 this.bottomConstraint, 
                                 this.yTickSize         );
        }
    },

    /**
     * Normally the drag element is moved pixel by pixel, but we can specify 
     * that it move a number of pixels at a time.  This method resolves the 
     * location when we have it set up like this.
     * @method getTick
     * @param {int} val where we want to place the object
     * @param {int[]} tickArray sorted array of valid points
     * @return {int} the closest tick
     * @private
     */
    getTick: function(val, tickArray) {

        if (!tickArray) {
            // If tick interval is not defined, it is effectively 1 pixel, 
            // so we return the value passed to us.
            return val; 
        } else if (tickArray[0] >= val) {
            // The value is lower than the first tick, so we return the first
            // tick.
            return tickArray[0];
        } else {
            for (var i=0, len=tickArray.length; i<len; ++i) {
                var next = i + 1;
                if (tickArray[next] && tickArray[next] >= val) {
                    var diff1 = val - tickArray[i];
                    var diff2 = tickArray[next] - val;
                    return (diff2 > diff1) ? tickArray[i] : tickArray[next];
                }
            }

            // The value is larger than the last tick, so we return the last
            // tick.
            return tickArray[tickArray.length - 1];
        }
    },

    /**
     * toString method
     * @method toString
     * @return {string} string representation of the dd obj
     */
    toString: function() {
        return ("DragDrop " + this.id);
    }

};
YAHOO.augment(YAHOO.util.DragDrop, YAHOO.util.EventProvider);

/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent 
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
})();
/**
 * A DragDrop implementation where the linked element follows the 
 * mouse cursor during a drag.
 * @class DD
 * @extends YAHOO.util.DragDrop
 * @constructor
 * @param {String} id the id of the linked element 
 * @param {String} sGroup the group of related DragDrop items
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DD: 
 *                    scroll
 */
YAHOO.util.DD = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config);
    }
};

YAHOO.extend(YAHOO.util.DD, YAHOO.util.DragDrop, {

    /**
     * When set to true, the utility automatically tries to scroll the browser
     * window when a drag and drop element is dragged near the viewport boundary.
     * Defaults to true.
     * @property scroll
     * @type boolean
     */
    scroll: true, 

    /**
     * Sets the pointer offset to the distance between the linked element's top 
     * left corner and the location the element was clicked
     * @method autoOffset
     * @param {int} iPageX the X coordinate of the click
     * @param {int} iPageY the Y coordinate of the click
     */
    autoOffset: function(iPageX, iPageY) {
        var x = iPageX - this.startPageX;
        var y = iPageY - this.startPageY;
        this.setDelta(x, y);
    },

    /** 
     * Sets the pointer offset.  You can call this directly to force the 
     * offset to be in a particular location (e.g., pass in 0,0 to set it 
     * to the center of the object, as done in YAHOO.widget.Slider)
     * @method setDelta
     * @param {int} iDeltaX the distance from the left
     * @param {int} iDeltaY the distance from the top
     */
    setDelta: function(iDeltaX, iDeltaY) {
        this.deltaX = iDeltaX;
        this.deltaY = iDeltaY;
    },

    /**
     * Sets the drag element to the location of the mousedown or click event, 
     * maintaining the cursor location relative to the location on the element 
     * that was clicked.  Override this if you want to place the element in a 
     * location other than where the cursor is.
     * @method setDragElPos
     * @param {int} iPageX the X coordinate of the mousedown or drag event
     * @param {int} iPageY the Y coordinate of the mousedown or drag event
     */
    setDragElPos: function(iPageX, iPageY) {
        // the first time we do this, we are going to check to make sure
        // the element has css positioning

        var el = this.getDragEl();
        this.alignElWithMouse(el, iPageX, iPageY);
    },

    /**
     * Sets the element to the location of the mousedown or click event, 
     * maintaining the cursor location relative to the location on the element 
     * that was clicked.  Override this if you want to place the element in a 
     * location other than where the cursor is.
     * @method alignElWithMouse
     * @param {HTMLElement} el the element to move
     * @param {int} iPageX the X coordinate of the mousedown or drag event
     * @param {int} iPageY the Y coordinate of the mousedown or drag event
     */
    alignElWithMouse: function(el, iPageX, iPageY) {
        var oCoord = this.getTargetCoord(iPageX, iPageY);

        if (!this.deltaSetXY) {
            var aCoord = [oCoord.x, oCoord.y];
            YAHOO.util.Dom.setXY(el, aCoord);

            var newLeft = parseInt( YAHOO.util.Dom.getStyle(el, "left"), 10 );
            var newTop  = parseInt( YAHOO.util.Dom.getStyle(el, "top" ), 10 );

            this.deltaSetXY = [ newLeft - oCoord.x, newTop - oCoord.y ];
        } else {
            YAHOO.util.Dom.setStyle(el, "left", (oCoord.x + this.deltaSetXY[0]) + "px");
            YAHOO.util.Dom.setStyle(el, "top",  (oCoord.y + this.deltaSetXY[1]) + "px");
        }
        
        this.cachePosition(oCoord.x, oCoord.y);
        var self = this;
        setTimeout(function() {
            self.autoScroll.call(self, oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
        }, 0);
    },

    /**
     * Saves the most recent position so that we can reset the constraints and
     * tick marks on-demand.  We need to know this so that we can calculate the
     * number of pixels the element is offset from its original position.
     * @method cachePosition
     * @param iPageX the current x position (optional, this just makes it so we
     * don't have to look it up again)
     * @param iPageY the current y position (optional, this just makes it so we
     * don't have to look it up again)
     */
    cachePosition: function(iPageX, iPageY) {
        if (iPageX) {
            this.lastPageX = iPageX;
            this.lastPageY = iPageY;
        } else {
            var aCoord = YAHOO.util.Dom.getXY(this.getEl());
            this.lastPageX = aCoord[0];
            this.lastPageY = aCoord[1];
        }
    },

    /**
     * Auto-scroll the window if the dragged object has been moved beyond the 
     * visible window boundary.
     * @method autoScroll
     * @param {int} x the drag element's x position
     * @param {int} y the drag element's y position
     * @param {int} h the height of the drag element
     * @param {int} w the width of the drag element
     * @private
     */
    autoScroll: function(x, y, h, w) {

        if (this.scroll) {
            // The client height
            var clientH = this.DDM.getClientHeight();

            // The client width
            var clientW = this.DDM.getClientWidth();

            // The amt scrolled down
            var st = this.DDM.getScrollTop();

            // The amt scrolled right
            var sl = this.DDM.getScrollLeft();

            // Location of the bottom of the element
            var bot = h + y;

            // Location of the right of the element
            var right = w + x;

            // The distance from the cursor to the bottom of the visible area, 
            // adjusted so that we don't scroll if the cursor is beyond the
            // element drag constraints
            var toBot = (clientH + st - y - this.deltaY);

            // The distance from the cursor to the right of the visible area
            var toRight = (clientW + sl - x - this.deltaX);


            // How close to the edge the cursor must be before we scroll
            // var thresh = (document.all) ? 100 : 40;
            var thresh = 40;

            // How many pixels to scroll per autoscroll op.  This helps to reduce 
            // clunky scrolling. IE is more sensitive about this ... it needs this 
            // value to be higher.
            var scrAmt = (document.all) ? 80 : 30;

            // Scroll down if we are near the bottom of the visible page and the 
            // obj extends below the crease
            if ( bot > clientH && toBot < thresh ) { 
                window.scrollTo(sl, st + scrAmt); 
            }

            // Scroll up if the window is scrolled down and the top of the object
            // goes above the top border
            if ( y < st && st > 0 && y - st < thresh ) { 
                window.scrollTo(sl, st - scrAmt); 
            }

            // Scroll right if the obj is beyond the right border and the cursor is
            // near the border.
            if ( right > clientW && toRight < thresh ) { 
                window.scrollTo(sl + scrAmt, st); 
            }

            // Scroll left if the window has been scrolled to the right and the obj
            // extends past the left border
            if ( x < sl && sl > 0 && x - sl < thresh ) { 
                window.scrollTo(sl - scrAmt, st);
            }
        }
    },

    /*
     * Sets up config options specific to this class. Overrides
     * YAHOO.util.DragDrop, but all versions of this method through the 
     * inheritance chain are called
     */
    applyConfig: function() {
        YAHOO.util.DD.superclass.applyConfig.call(this);
        this.scroll = (this.config.scroll !== false);
    },

    /*
     * Event that fires prior to the onMouseDown event.  Overrides 
     * YAHOO.util.DragDrop.
     */
    b4MouseDown: function(e) {
        this.setStartPosition();
        // this.resetConstraints();
        this.autoOffset(YAHOO.util.Event.getPageX(e), 
                            YAHOO.util.Event.getPageY(e));
    },

    /*
     * Event that fires prior to the onDrag event.  Overrides 
     * YAHOO.util.DragDrop.
     */
    b4Drag: function(e) {
        this.setDragElPos(YAHOO.util.Event.getPageX(e), 
                            YAHOO.util.Event.getPageY(e));
    },

    toString: function() {
        return ("DD " + this.id);
    }

    //////////////////////////////////////////////////////////////////////////
    // Debugging ygDragDrop events that can be overridden
    //////////////////////////////////////////////////////////////////////////
    /*
    startDrag: function(x, y) {
    },

    onDrag: function(e) {
    },

    onDragEnter: function(e, id) {
    },

    onDragOver: function(e, id) {
    },

    onDragOut: function(e, id) {
    },

    onDragDrop: function(e, id) {
    },

    endDrag: function(e) {
    }

    */

/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent 
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
});
/**
 * A DragDrop implementation that inserts an empty, bordered div into
 * the document that follows the cursor during drag operations.  At the time of
 * the click, the frame div is resized to the dimensions of the linked html
 * element, and moved to the exact location of the linked element.
 *
 * References to the "frame" element refer to the single proxy element that
 * was created to be dragged in place of all DDProxy elements on the
 * page.
 *
 * @class DDProxy
 * @extends YAHOO.util.DD
 * @constructor
 * @param {String} id the id of the linked html element
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DDProxy in addition to those in DragDrop: 
 *                   resizeFrame, centerFrame, dragElId
 */
YAHOO.util.DDProxy = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config);
        this.initFrame(); 
    }
};

/**
 * The default drag frame div id
 * @property YAHOO.util.DDProxy.dragElId
 * @type String
 * @static
 */
YAHOO.util.DDProxy.dragElId = "ygddfdiv";

YAHOO.extend(YAHOO.util.DDProxy, YAHOO.util.DD, {

    /**
     * By default we resize the drag frame to be the same size as the element
     * we want to drag (this is to get the frame effect).  We can turn it off
     * if we want a different behavior.
     * @property resizeFrame
     * @type boolean
     */
    resizeFrame: true,

    /**
     * By default the frame is positioned exactly where the drag element is, so
     * we use the cursor offset provided by YAHOO.util.DD.  Another option that works only if
     * you do not have constraints on the obj is to have the drag frame centered
     * around the cursor.  Set centerFrame to true for this effect.
     * @property centerFrame
     * @type boolean
     */
    centerFrame: false,

    /**
     * Creates the proxy element if it does not yet exist
     * @method createFrame
     */
    createFrame: function() {
        var self=this, body=document.body;

        if (!body || !body.firstChild) {
            setTimeout( function() { self.createFrame(); }, 50 );
            return;
        }

        var div=this.getDragEl(), Dom=YAHOO.util.Dom;

        if (!div) {
            div    = document.createElement("div");
            div.id = this.dragElId;
            var s  = div.style;

            s.position   = "absolute";
            s.visibility = "hidden";
            s.cursor     = "move";
            s.border     = "2px solid #aaa";
            s.zIndex     = 999;
            s.height     = "25px";
            s.width      = "25px";

            var _data = document.createElement('div');
            Dom.setStyle(_data, 'height', '100%');
            Dom.setStyle(_data, 'width', '100%');
            /**
            * If the proxy element has no background-color, then it is considered to the "transparent" by Internet Explorer.
            * Since it is "transparent" then the events pass through it to the iframe below.
            * So creating a "fake" div inside the proxy element and giving it a background-color, then setting it to an
            * opacity of 0, it appears to not be there, however IE still thinks that it is so the events never pass through.
            */
            Dom.setStyle(_data, 'background-color', '#ccc');
            Dom.setStyle(_data, 'opacity', '0');
            div.appendChild(_data);

            // appendChild can blow up IE if invoked prior to the window load event
            // while rendering a table.  It is possible there are other scenarios 
            // that would cause this to happen as well.
            body.insertBefore(div, body.firstChild);
        }
    },

    /**
     * Initialization for the drag frame element.  Must be called in the
     * constructor of all subclasses
     * @method initFrame
     */
    initFrame: function() {
        this.createFrame();
    },

    applyConfig: function() {
        YAHOO.util.DDProxy.superclass.applyConfig.call(this);

        this.resizeFrame = (this.config.resizeFrame !== false);
        this.centerFrame = (this.config.centerFrame);
        this.setDragElId(this.config.dragElId || YAHOO.util.DDProxy.dragElId);
    },

    /**
     * Resizes the drag frame to the dimensions of the clicked object, positions 
     * it over the object, and finally displays it
     * @method showFrame
     * @param {int} iPageX X click position
     * @param {int} iPageY Y click position
     * @private
     */
    showFrame: function(iPageX, iPageY) {
        var el = this.getEl();
        var dragEl = this.getDragEl();
        var s = dragEl.style;

        this._resizeProxy();

        if (this.centerFrame) {
            this.setDelta( Math.round(parseInt(s.width,  10)/2), 
                           Math.round(parseInt(s.height, 10)/2) );
        }

        this.setDragElPos(iPageX, iPageY);

        YAHOO.util.Dom.setStyle(dragEl, "visibility", "visible"); 
    },

    /**
     * The proxy is automatically resized to the dimensions of the linked
     * element when a drag is initiated, unless resizeFrame is set to false
     * @method _resizeProxy
     * @private
     */
    _resizeProxy: function() {
        if (this.resizeFrame) {
            var DOM    = YAHOO.util.Dom;
            var el     = this.getEl();
            var dragEl = this.getDragEl();

            var bt = parseInt( DOM.getStyle(dragEl, "borderTopWidth"    ), 10);
            var br = parseInt( DOM.getStyle(dragEl, "borderRightWidth"  ), 10);
            var bb = parseInt( DOM.getStyle(dragEl, "borderBottomWidth" ), 10);
            var bl = parseInt( DOM.getStyle(dragEl, "borderLeftWidth"   ), 10);

            if (isNaN(bt)) { bt = 0; }
            if (isNaN(br)) { br = 0; }
            if (isNaN(bb)) { bb = 0; }
            if (isNaN(bl)) { bl = 0; }


            var newWidth  = Math.max(0, el.offsetWidth  - br - bl);                                                                                           
            var newHeight = Math.max(0, el.offsetHeight - bt - bb);


            DOM.setStyle( dragEl, "width",  newWidth  + "px" );
            DOM.setStyle( dragEl, "height", newHeight + "px" );
        }
    },

    // overrides YAHOO.util.DragDrop
    b4MouseDown: function(e) {
        this.setStartPosition();
        var x = YAHOO.util.Event.getPageX(e);
        var y = YAHOO.util.Event.getPageY(e);
        this.autoOffset(x, y);

        // This causes the autoscroll code to kick off, which means autoscroll can
        // happen prior to the check for a valid drag handle.
        // this.setDragElPos(x, y);
    },

    // overrides YAHOO.util.DragDrop
    b4StartDrag: function(x, y) {
        // show the drag frame
        this.showFrame(x, y);
    },

    // overrides YAHOO.util.DragDrop
    b4EndDrag: function(e) {
        YAHOO.util.Dom.setStyle(this.getDragEl(), "visibility", "hidden"); 
    },

    // overrides YAHOO.util.DragDrop
    // By default we try to move the element to the last location of the frame.  
    // This is so that the default behavior mirrors that of YAHOO.util.DD.  
    endDrag: function(e) {
        var DOM = YAHOO.util.Dom;
        var lel = this.getEl();
        var del = this.getDragEl();

        // Show the drag frame briefly so we can get its position
        // del.style.visibility = "";
        DOM.setStyle(del, "visibility", ""); 

        // Hide the linked element before the move to get around a Safari 
        // rendering bug.
        //lel.style.visibility = "hidden";
        DOM.setStyle(lel, "visibility", "hidden"); 
        YAHOO.util.DDM.moveToEl(lel, del);
        //del.style.visibility = "hidden";
        DOM.setStyle(del, "visibility", "hidden"); 
        //lel.style.visibility = "";
        DOM.setStyle(lel, "visibility", ""); 
    },

    toString: function() {
        return ("DDProxy " + this.id);
    }
/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent 
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

});
/**
 * A DragDrop implementation that does not move, but can be a drop 
 * target.  You would get the same result by simply omitting implementation 
 * for the event callbacks, but this way we reduce the processing cost of the 
 * event listener and the callbacks.
 * @class DDTarget
 * @extends YAHOO.util.DragDrop 
 * @constructor
 * @param {String} id the id of the element that is a drop target
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                 Valid properties for DDTarget in addition to those in 
 *                 DragDrop: 
 *                    none
 */
YAHOO.util.DDTarget = function(id, sGroup, config) {
    if (id) {
        this.initTarget(id, sGroup, config);
    }
};

// YAHOO.util.DDTarget.prototype = new YAHOO.util.DragDrop();
YAHOO.extend(YAHOO.util.DDTarget, YAHOO.util.DragDrop, {
    toString: function() {
        return ("DDTarget " + this.id);
    }
});
YAHOO.register("dragdrop", YAHOO.util.DragDropMgr, {version: "2.8.1", build: "19"});
/*
Copyright (c) 2010, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.8.1
*/
/**
 * The drag and drop utility provides a framework for building drag and drop
 * applications.  In addition to enabling drag and drop for specific elements,
 * the drag and drop elements are tracked by the manager class, and the
 * interactions between the various elements are tracked during the drag and
 * the implementing code is notified about these important moments.
 * @module dragdrop
 * @title Drag and Drop
 * @requires yahoo,dom,event
 * @namespace YAHOO.util
 */

// Only load the library once.  Rewriting the manager class would orphan 
// existing drag and drop instances.
if (!YAHOO.util.DragDropMgr) {

/**
 * DragDropMgr is a singleton that tracks the element interaction for 
 * all DragDrop items in the window.  Generally, you will not call 
 * this class directly, but it does have helper methods that could 
 * be useful in your DragDrop implementations.
 * @class DragDropMgr
 * @static
 */
YAHOO.util.DragDropMgr = function() {

    var Event = YAHOO.util.Event,
        Dom = YAHOO.util.Dom;

    return {
        /**
        * This property is used to turn on global use of the shim element on all DragDrop instances, defaults to false for backcompat. (Use: YAHOO.util.DDM.useShim = true)
        * @property useShim
        * @type Boolean
        * @static
        */
        useShim: false,
        /**
        * This property is used to determine if the shim is active over the screen, default false.
        * @private
        * @property _shimActive
        * @type Boolean
        * @static
        */
        _shimActive: false,
        /**
        * This property is used when useShim is set on a DragDrop object to store the current state of DDM.useShim so it can be reset when a drag operation is done.
        * @private
        * @property _shimState
        * @type Boolean
        * @static
        */
        _shimState: false,
        /**
        * This property is used when useShim is set to true, it will set the opacity on the shim to .5 for debugging. Use: (YAHOO.util.DDM._debugShim = true;)
        * @private
        * @property _debugShim
        * @type Boolean
        * @static
        */
        _debugShim: false,
        /**
        * This method will create a shim element (giving it the id of yui-ddm-shim), it also attaches the mousemove and mouseup listeners to it and attaches a scroll listener on the window
        * @private
        * @method _sizeShim
        * @static
        */
        _createShim: function() {
            var s = document.createElement('div');
            s.id = 'yui-ddm-shim';
            if (document.body.firstChild) {
                document.body.insertBefore(s, document.body.firstChild);
            } else {
                document.body.appendChild(s);
            }
            s.style.display = 'none';
            s.style.backgroundColor = 'red';
            s.style.position = 'absolute';
            s.style.zIndex = '99999';
            Dom.setStyle(s, 'opacity', '0');
            this._shim = s;
            Event.on(s, "mouseup",   this.handleMouseUp, this, true);
            Event.on(s, "mousemove", this.handleMouseMove, this, true);
            Event.on(window, 'scroll', this._sizeShim, this, true);
        },
        /**
        * This method will size the shim, called from activate and on window scroll event
        * @private
        * @method _sizeShim
        * @static
        */
        _sizeShim: function() {
            if (this._shimActive) {
                var s = this._shim;
                s.style.height = Dom.getDocumentHeight() + 'px';
                s.style.width = Dom.getDocumentWidth() + 'px';
                s.style.top = '0';
                s.style.left = '0';
            }
        },
        /**
        * This method will create the shim element if needed, then show the shim element, size the element and set the _shimActive property to true
        * @private
        * @method _activateShim
        * @static
        */
        _activateShim: function() {
            if (this.useShim) {
                if (!this._shim) {
                    this._createShim();
                }
                this._shimActive = true;
                var s = this._shim,
                    o = '0';
                if (this._debugShim) {
                    o = '.5';
                }
                Dom.setStyle(s, 'opacity', o);
                this._sizeShim();
                s.style.display = 'block';
            }
        },
        /**
        * This method will hide the shim element and set the _shimActive property to false
        * @private
        * @method _deactivateShim
        * @static
        */
        _deactivateShim: function() {
            this._shim.style.display = 'none';
            this._shimActive = false;
        },
        /**
        * The HTML element created to use as a shim over the document to track mouse movements
        * @private
        * @property _shim
        * @type HTMLElement
        * @static
        */
        _shim: null,
        /**
         * Two dimensional Array of registered DragDrop objects.  The first 
         * dimension is the DragDrop item group, the second the DragDrop 
         * object.
         * @property ids
         * @type {string: string}
         * @private
         * @static
         */
        ids: {},

        /**
         * Array of element ids defined as drag handles.  Used to determine 
         * if the element that generated the mousedown event is actually the 
         * handle and not the html element itself.
         * @property handleIds
         * @type {string: string}
         * @private
         * @static
         */
        handleIds: {},

        /**
         * the DragDrop object that is currently being dragged
         * @property dragCurrent
         * @type DragDrop
         * @private
         * @static
         **/
        dragCurrent: null,

        /**
         * the DragDrop object(s) that are being hovered over
         * @property dragOvers
         * @type Array
         * @private
         * @static
         */
        dragOvers: {},

        /**
         * the X distance between the cursor and the object being dragged
         * @property deltaX
         * @type int
         * @private
         * @static
         */
        deltaX: 0,

        /**
         * the Y distance between the cursor and the object being dragged
         * @property deltaY
         * @type int
         * @private
         * @static
         */
        deltaY: 0,

        /**
         * Flag to determine if we should prevent the default behavior of the
         * events we define. By default this is true, but this can be set to 
         * false if you need the default behavior (not recommended)
         * @property preventDefault
         * @type boolean
         * @static
         */
        preventDefault: true,

        /**
         * Flag to determine if we should stop the propagation of the events 
         * we generate. This is true by default but you may want to set it to
         * false if the html element contains other features that require the
         * mouse click.
         * @property stopPropagation
         * @type boolean
         * @static
         */
        stopPropagation: true,

        /**
         * Internal flag that is set to true when drag and drop has been
         * initialized
         * @property initialized
         * @private
         * @static
         */
        initialized: false,

        /**
         * All drag and drop can be disabled.
         * @property locked
         * @private
         * @static
         */
        locked: false,

        /**
         * Provides additional information about the the current set of
         * interactions.  Can be accessed from the event handlers. It
         * contains the following properties:
         *
         *       out:       onDragOut interactions
         *       enter:     onDragEnter interactions
         *       over:      onDragOver interactions
         *       drop:      onDragDrop interactions
         *       point:     The location of the cursor
         *       draggedRegion: The location of dragged element at the time
         *                      of the interaction
         *       sourceRegion: The location of the source elemtn at the time
         *                     of the interaction
         *       validDrop: boolean
         * @property interactionInfo
         * @type object
         * @static
         */
        interactionInfo: null,

        /**
         * Called the first time an element is registered.
         * @method init
         * @private
         * @static
         */
        init: function() {
            this.initialized = true;
        },

        /**
         * In point mode, drag and drop interaction is defined by the 
         * location of the cursor during the drag/drop
         * @property POINT
         * @type int
         * @static
         * @final
         */
        POINT: 0,

        /**
         * In intersect mode, drag and drop interaction is defined by the 
         * cursor position or the amount of overlap of two or more drag and 
         * drop objects.
         * @property INTERSECT
         * @type int
         * @static
         * @final
         */
        INTERSECT: 1,

        /**
         * In intersect mode, drag and drop interaction is defined only by the 
         * overlap of two or more drag and drop objects.
         * @property STRICT_INTERSECT
         * @type int
         * @static
         * @final
         */
        STRICT_INTERSECT: 2,

        /**
         * The current drag and drop mode.  Default: POINT
         * @property mode
         * @type int
         * @static
         */
        mode: 0,

        /**
         * Runs method on all drag and drop objects
         * @method _execOnAll
         * @private
         * @static
         */
        _execOnAll: function(sMethod, args) {
            for (var i in this.ids) {
                for (var j in this.ids[i]) {
                    var oDD = this.ids[i][j];
                    if (! this.isTypeOfDD(oDD)) {
                        continue;
                    }
                    oDD[sMethod].apply(oDD, args);
                }
            }
        },

        /**
         * Drag and drop initialization.  Sets up the global event handlers
         * @method _onLoad
         * @private
         * @static
         */
        _onLoad: function() {

            this.init();

            Event.on(document, "mouseup",   this.handleMouseUp, this, true);
            Event.on(document, "mousemove", this.handleMouseMove, this, true);
            Event.on(window,   "unload",    this._onUnload, this, true);
            Event.on(window,   "resize",    this._onResize, this, true);
            // Event.on(window,   "mouseout",    this._test);

        },

        /**
         * Reset constraints on all drag and drop objs
         * @method _onResize
         * @private
         * @static
         */
        _onResize: function(e) {
            this._execOnAll("resetConstraints", []);
        },

        /**
         * Lock all drag and drop functionality
         * @method lock
         * @static
         */
        lock: function() { this.locked = true; },

        /**
         * Unlock all drag and drop functionality
         * @method unlock
         * @static
         */
        unlock: function() { this.locked = false; },

        /**
         * Is drag and drop locked?
         * @method isLocked
         * @return {boolean} True if drag and drop is locked, false otherwise.
         * @static
         */
        isLocked: function() { return this.locked; },

        /**
         * Location cache that is set for all drag drop objects when a drag is
         * initiated, cleared when the drag is finished.
         * @property locationCache
         * @private
         * @static
         */
        locationCache: {},

        /**
         * Set useCache to false if you want to force object the lookup of each
         * drag and drop linked element constantly during a drag.
         * @property useCache
         * @type boolean
         * @static
         */
        useCache: true,

        /**
         * The number of pixels that the mouse needs to move after the 
         * mousedown before the drag is initiated.  Default=3;
         * @property clickPixelThresh
         * @type int
         * @static
         */
        clickPixelThresh: 3,

        /**
         * The number of milliseconds after the mousedown event to initiate the
         * drag if we don't get a mouseup event. Default=1000
         * @property clickTimeThresh
         * @type int
         * @static
         */
        clickTimeThresh: 1000,

        /**
         * Flag that indicates that either the drag pixel threshold or the 
         * mousdown time threshold has been met
         * @property dragThreshMet
         * @type boolean
         * @private
         * @static
         */
        dragThreshMet: false,

        /**
         * Timeout used for the click time threshold
         * @property clickTimeout
         * @type Object
         * @private
         * @static
         */
        clickTimeout: null,

        /**
         * The X position of the mousedown event stored for later use when a 
         * drag threshold is met.
         * @property startX
         * @type int
         * @private
         * @static
         */
        startX: 0,

        /**
         * The Y position of the mousedown event stored for later use when a 
         * drag threshold is met.
         * @property startY
         * @type int
         * @private
         * @static
         */
        startY: 0,

        /**
         * Flag to determine if the drag event was fired from the click timeout and
         * not the mouse move threshold.
         * @property fromTimeout
         * @type boolean
         * @private
         * @static
         */
        fromTimeout: false,

        /**
         * Each DragDrop instance must be registered with the DragDropMgr.  
         * This is executed in DragDrop.init()
         * @method regDragDrop
         * @param {DragDrop} oDD the DragDrop object to register
         * @param {String} sGroup the name of the group this element belongs to
         * @static
         */
        regDragDrop: function(oDD, sGroup) {
            if (!this.initialized) { this.init(); }
            
            if (!this.ids[sGroup]) {
                this.ids[sGroup] = {};
            }
            this.ids[sGroup][oDD.id] = oDD;
        },

        /**
         * Removes the supplied dd instance from the supplied group. Executed
         * by DragDrop.removeFromGroup, so don't call this function directly.
         * @method removeDDFromGroup
         * @private
         * @static
         */
        removeDDFromGroup: function(oDD, sGroup) {
            if (!this.ids[sGroup]) {
                this.ids[sGroup] = {};
            }

            var obj = this.ids[sGroup];
            if (obj && obj[oDD.id]) {
                delete obj[oDD.id];
            }
        },

        /**
         * Unregisters a drag and drop item.  This is executed in 
         * DragDrop.unreg, use that method instead of calling this directly.
         * @method _remove
         * @private
         * @static
         */
        _remove: function(oDD) {
            for (var g in oDD.groups) {
                if (g) {
                    var item = this.ids[g];
                    if (item && item[oDD.id]) {
                        delete item[oDD.id];
                    }
                }
                
            }
            delete this.handleIds[oDD.id];
        },

        /**
         * Each DragDrop handle element must be registered.  This is done
         * automatically when executing DragDrop.setHandleElId()
         * @method regHandle
         * @param {String} sDDId the DragDrop id this element is a handle for
         * @param {String} sHandleId the id of the element that is the drag 
         * handle
         * @static
         */
        regHandle: function(sDDId, sHandleId) {
            if (!this.handleIds[sDDId]) {
                this.handleIds[sDDId] = {};
            }
            this.handleIds[sDDId][sHandleId] = sHandleId;
        },

        /**
         * Utility function to determine if a given element has been 
         * registered as a drag drop item.
         * @method isDragDrop
         * @param {String} id the element id to check
         * @return {boolean} true if this element is a DragDrop item, 
         * false otherwise
         * @static
         */
        isDragDrop: function(id) {
            return ( this.getDDById(id) ) ? true : false;
        },

        /**
         * Returns the drag and drop instances that are in all groups the
         * passed in instance belongs to.
         * @method getRelated
         * @param {DragDrop} p_oDD the obj to get related data for
         * @param {boolean} bTargetsOnly if true, only return targetable objs
         * @return {DragDrop[]} the related instances
         * @static
         */
        getRelated: function(p_oDD, bTargetsOnly) {
            var oDDs = [];
            for (var i in p_oDD.groups) {
                for (var j in this.ids[i]) {
                    var dd = this.ids[i][j];
                    if (! this.isTypeOfDD(dd)) {
                        continue;
                    }
                    if (!bTargetsOnly || dd.isTarget) {
                        oDDs[oDDs.length] = dd;
                    }
                }
            }

            return oDDs;
        },

        /**
         * Returns true if the specified dd target is a legal target for 
         * the specifice drag obj
         * @method isLegalTarget
         * @param {DragDrop} the drag obj
         * @param {DragDrop} the target
         * @return {boolean} true if the target is a legal target for the 
         * dd obj
         * @static
         */
        isLegalTarget: function (oDD, oTargetDD) {
            var targets = this.getRelated(oDD, true);
            for (var i=0, len=targets.length;i<len;++i) {
                if (targets[i].id == oTargetDD.id) {
                    return true;
                }
            }

            return false;
        },

        /**
         * My goal is to be able to transparently determine if an object is
         * typeof DragDrop, and the exact subclass of DragDrop.  typeof 
         * returns "object", oDD.constructor.toString() always returns
         * "DragDrop" and not the name of the subclass.  So for now it just
         * evaluates a well-known variable in DragDrop.
         * @method isTypeOfDD
         * @param {Object} the object to evaluate
         * @return {boolean} true if typeof oDD = DragDrop
         * @static
         */
        isTypeOfDD: function (oDD) {
            return (oDD && oDD.__ygDragDrop);
        },

        /**
         * Utility function to determine if a given element has been 
         * registered as a drag drop handle for the given Drag Drop object.
         * @method isHandle
         * @param {String} id the element id to check
         * @return {boolean} true if this element is a DragDrop handle, false 
         * otherwise
         * @static
         */
        isHandle: function(sDDId, sHandleId) {
            return ( this.handleIds[sDDId] && 
                            this.handleIds[sDDId][sHandleId] );
        },

        /**
         * Returns the DragDrop instance for a given id
         * @method getDDById
         * @param {String} id the id of the DragDrop object
         * @return {DragDrop} the drag drop object, null if it is not found
         * @static
         */
        getDDById: function(id) {
            for (var i in this.ids) {
                if (this.ids[i][id]) {
                    return this.ids[i][id];
                }
            }
            return null;
        },

        /**
         * Fired after a registered DragDrop object gets the mousedown event.
         * Sets up the events required to track the object being dragged
         * @method handleMouseDown
         * @param {Event} e the event
         * @param oDD the DragDrop object being dragged
         * @private
         * @static
         */
        handleMouseDown: function(e, oDD) {
            //this._activateShim();

            this.currentTarget = YAHOO.util.Event.getTarget(e);

            this.dragCurrent = oDD;

            var el = oDD.getEl();

            // track start position
            this.startX = YAHOO.util.Event.getPageX(e);
            this.startY = YAHOO.util.Event.getPageY(e);

            this.deltaX = this.startX - el.offsetLeft;
            this.deltaY = this.startY - el.offsetTop;

            this.dragThreshMet = false;

            this.clickTimeout = setTimeout( 
                    function() { 
                        var DDM = YAHOO.util.DDM;
                        DDM.startDrag(DDM.startX, DDM.startY);
                        DDM.fromTimeout = true;
                    }, 
                    this.clickTimeThresh );
        },

        /**
         * Fired when either the drag pixel threshold or the mousedown hold 
         * time threshold has been met.
         * @method startDrag
         * @param x {int} the X position of the original mousedown
         * @param y {int} the Y position of the original mousedown
         * @static
         */
        startDrag: function(x, y) {
            if (this.dragCurrent && this.dragCurrent.useShim) {
                this._shimState = this.useShim;
                this.useShim = true;
            }
            this._activateShim();
            clearTimeout(this.clickTimeout);
            var dc = this.dragCurrent;
            if (dc && dc.events.b4StartDrag) {
                dc.b4StartDrag(x, y);
                dc.fireEvent('b4StartDragEvent', { x: x, y: y });
            }
            if (dc && dc.events.startDrag) {
                dc.startDrag(x, y);
                dc.fireEvent('startDragEvent', { x: x, y: y });
            }
            this.dragThreshMet = true;
        },

        /**
         * Internal function to handle the mouseup event.  Will be invoked 
         * from the context of the document.
         * @method handleMouseUp
         * @param {Event} e the event
         * @private
         * @static
         */
        handleMouseUp: function(e) {
            if (this.dragCurrent) {
                clearTimeout(this.clickTimeout);

                if (this.dragThreshMet) {
                    if (this.fromTimeout) {
                        this.fromTimeout = false;
                        this.handleMouseMove(e);
                    }
                    this.fromTimeout = false;
                    this.fireEvents(e, true);
                } else {
                }

                this.stopDrag(e);

                this.stopEvent(e);
            }
        },

        /**
         * Utility to stop event propagation and event default, if these 
         * features are turned on.
         * @method stopEvent
         * @param {Event} e the event as returned by this.getEvent()
         * @static
         */
        stopEvent: function(e) {
            if (this.stopPropagation) {
                YAHOO.util.Event.stopPropagation(e);
            }

            if (this.preventDefault) {
                YAHOO.util.Event.preventDefault(e);
            }
        },

        /** 
         * Ends the current drag, cleans up the state, and fires the endDrag
         * and mouseUp events.  Called internally when a mouseup is detected
         * during the drag.  Can be fired manually during the drag by passing
         * either another event (such as the mousemove event received in onDrag)
         * or a fake event with pageX and pageY defined (so that endDrag and
         * onMouseUp have usable position data.).  Alternatively, pass true
         * for the silent parameter so that the endDrag and onMouseUp events
         * are skipped (so no event data is needed.)
         *
         * @method stopDrag
         * @param {Event} e the mouseup event, another event (or a fake event) 
         *                  with pageX and pageY defined, or nothing if the 
         *                  silent parameter is true
         * @param {boolean} silent skips the enddrag and mouseup events if true
         * @static
         */
        stopDrag: function(e, silent) {
            var dc = this.dragCurrent;
            // Fire the drag end event for the item that was dragged
            if (dc && !silent) {
                if (this.dragThreshMet) {
                    if (dc.events.b4EndDrag) {
                        dc.b4EndDrag(e);
                        dc.fireEvent('b4EndDragEvent', { e: e });
                    }
                    if (dc.events.endDrag) {
                        dc.endDrag(e);
                        dc.fireEvent('endDragEvent', { e: e });
                    }
                }
                if (dc.events.mouseUp) {
                    dc.onMouseUp(e);
                    dc.fireEvent('mouseUpEvent', { e: e });
                }
            }

            if (this._shimActive) {
                this._deactivateShim();
                if (this.dragCurrent && this.dragCurrent.useShim) {
                    this.useShim = this._shimState;
                    this._shimState = false;
                }
            }

            this.dragCurrent = null;
            this.dragOvers = {};
        },

        /** 
         * Internal function to handle the mousemove event.  Will be invoked 
         * from the context of the html element.
         *
         * @TODO figure out what we can do about mouse events lost when the 
         * user drags objects beyond the window boundary.  Currently we can 
         * detect this in internet explorer by verifying that the mouse is 
         * down during the mousemove event.  Firefox doesn't give us the 
         * button state on the mousemove event.
         * @method handleMouseMove
         * @param {Event} e the event
         * @private
         * @static
         */
        handleMouseMove: function(e) {

            var dc = this.dragCurrent;
            if (dc) {

                // var button = e.which || e.button;

                // check for IE < 9 mouseup outside of page boundary
                if (YAHOO.env.ua.ie && (YAHOO.env.ua.ie < 9) && !e.button) {
                    this.stopEvent(e);
                    return this.handleMouseUp(e);
                } else {
                    if (e.clientX < 0 || e.clientY < 0) {
                        //This will stop the element from leaving the viewport in FF, Opera & Safari
                        //Not turned on yet
                        //this.stopEvent(e);
                        //return false;
                    }
                }

                if (!this.dragThreshMet) {
                    var diffX = Math.abs(this.startX - YAHOO.util.Event.getPageX(e));
                    var diffY = Math.abs(this.startY - YAHOO.util.Event.getPageY(e));
                    if (diffX > this.clickPixelThresh || 
                                diffY > this.clickPixelThresh) {
                        this.startDrag(this.startX, this.startY);
                    }
                }

                if (this.dragThreshMet) {
                    if (dc && dc.events.b4Drag) {
                        dc.b4Drag(e);
                        dc.fireEvent('b4DragEvent', { e: e});
                    }
                    if (dc && dc.events.drag) {
                        dc.onDrag(e);
                        dc.fireEvent('dragEvent', { e: e});
                    }
                    if (dc) {
                        this.fireEvents(e, false);
                    }
                }

                this.stopEvent(e);
            }
        },
        
        /**
         * Iterates over all of the DragDrop elements to find ones we are 
         * hovering over or dropping on
         * @method fireEvents
         * @param {Event} e the event
         * @param {boolean} isDrop is this a drop op or a mouseover op?
         * @private
         * @static
         */
        fireEvents: function(e, isDrop) {
            var dc = this.dragCurrent;

            // If the user did the mouse up outside of the window, we could 
            // get here even though we have ended the drag.
            // If the config option dragOnly is true, bail out and don't fire the events
            if (!dc || dc.isLocked() || dc.dragOnly) {
                return;
            }

            var x = YAHOO.util.Event.getPageX(e),
                y = YAHOO.util.Event.getPageY(e),
                pt = new YAHOO.util.Point(x,y),
                pos = dc.getTargetCoord(pt.x, pt.y),
                el = dc.getDragEl(),
                events = ['out', 'over', 'drop', 'enter'],
                curRegion = new YAHOO.util.Region( pos.y, 
                                               pos.x + el.offsetWidth,
                                               pos.y + el.offsetHeight, 
                                               pos.x ),
            
                oldOvers = [], // cache the previous dragOver array
                inGroupsObj  = {},
                inGroups  = [],
                data = {
                    outEvts: [],
                    overEvts: [],
                    dropEvts: [],
                    enterEvts: []
                };


            // Check to see if the object(s) we were hovering over is no longer 
            // being hovered over so we can fire the onDragOut event
            for (var i in this.dragOvers) {

                var ddo = this.dragOvers[i];

                if (! this.isTypeOfDD(ddo)) {
                    continue;
                }
                if (! this.isOverTarget(pt, ddo, this.mode, curRegion)) {
                    data.outEvts.push( ddo );
                }

                oldOvers[i] = true;
                delete this.dragOvers[i];
            }

            for (var sGroup in dc.groups) {
                
                if ("string" != typeof sGroup) {
                    continue;
                }

                for (i in this.ids[sGroup]) {
                    var oDD = this.ids[sGroup][i];
                    if (! this.isTypeOfDD(oDD)) {
                        continue;
                    }

                    if (oDD.isTarget && !oDD.isLocked() && oDD != dc) {
                        if (this.isOverTarget(pt, oDD, this.mode, curRegion)) {
                            inGroupsObj[sGroup] = true;
                            // look for drop interactions
                            if (isDrop) {
                                data.dropEvts.push( oDD );
                            // look for drag enter and drag over interactions
                            } else {

                                // initial drag over: dragEnter fires
                                if (!oldOvers[oDD.id]) {
                                    data.enterEvts.push( oDD );
                                // subsequent drag overs: dragOver fires
                                } else {
                                    data.overEvts.push( oDD );
                                }

                                this.dragOvers[oDD.id] = oDD;
                            }
                        }
                    }
                }
            }

            this.interactionInfo = {
                out:       data.outEvts,
                enter:     data.enterEvts,
                over:      data.overEvts,
                drop:      data.dropEvts,
                point:     pt,
                draggedRegion:    curRegion,
                sourceRegion: this.locationCache[dc.id],
                validDrop: isDrop
            };

            
            for (var inG in inGroupsObj) {
                inGroups.push(inG);
            }

            // notify about a drop that did not find a target
            if (isDrop && !data.dropEvts.length) {
                this.interactionInfo.validDrop = false;
                if (dc.events.invalidDrop) {
                    dc.onInvalidDrop(e);
                    dc.fireEvent('invalidDropEvent', { e: e });
                }
            }
            for (i = 0; i < events.length; i++) {
                var tmp = null;
                if (data[events[i] + 'Evts']) {
                    tmp = data[events[i] + 'Evts'];
                }
                if (tmp && tmp.length) {
                    var type = events[i].charAt(0).toUpperCase() + events[i].substr(1),
                        ev = 'onDrag' + type,
                        b4 = 'b4Drag' + type,
                        cev = 'drag' + type + 'Event',
                        check = 'drag' + type;
                    if (this.mode) {
                        if (dc.events[b4]) {
                            dc[b4](e, tmp, inGroups);
                            dc.fireEvent(b4 + 'Event', { event: e, info: tmp, group: inGroups });
                            
                        }
                        if (dc.events[check]) {
                            dc[ev](e, tmp, inGroups);
                            dc.fireEvent(cev, { event: e, info: tmp, group: inGroups });
                        }
                    } else {
                        for (var b = 0, len = tmp.length; b < len; ++b) {
                            if (dc.events[b4]) {
                                dc[b4](e, tmp[b].id, inGroups[0]);
                                dc.fireEvent(b4 + 'Event', { event: e, info: tmp[b].id, group: inGroups[0] });
                            }
                            if (dc.events[check]) {
                                dc[ev](e, tmp[b].id, inGroups[0]);
                                dc.fireEvent(cev, { event: e, info: tmp[b].id, group: inGroups[0] });
                            }
                        }
                    }
                }
            }
        },

        /**
         * Helper function for getting the best match from the list of drag 
         * and drop objects returned by the drag and drop events when we are 
         * in INTERSECT mode.  It returns either the first object that the 
         * cursor is over, or the object that has the greatest overlap with 
         * the dragged element.
         * @method getBestMatch
         * @param  {DragDrop[]} dds The array of drag and drop objects 
         * targeted
         * @return {DragDrop}       The best single match
         * @static
         */
        getBestMatch: function(dds) {
            var winner = null;

            var len = dds.length;

            if (len == 1) {
                winner = dds[0];
            } else {
                // Loop through the targeted items
                for (var i=0; i<len; ++i) {
                    var dd = dds[i];
                    // If the cursor is over the object, it wins.  If the 
                    // cursor is over multiple matches, the first one we come
                    // to wins.
                    if (this.mode == this.INTERSECT && dd.cursorIsOver) {
                        winner = dd;
                        break;
                    // Otherwise the object with the most overlap wins
                    } else {
                        if (!winner || !winner.overlap || (dd.overlap &&
                            winner.overlap.getArea() < dd.overlap.getArea())) {
                            winner = dd;
                        }
                    }
                }
            }

            return winner;
        },

        /**
         * Refreshes the cache of the top-left and bottom-right points of the 
         * drag and drop objects in the specified group(s).  This is in the
         * format that is stored in the drag and drop instance, so typical 
         * usage is:
         * <code>
         * YAHOO.util.DragDropMgr.refreshCache(ddinstance.groups);
         * </code>
         * Alternatively:
         * <code>
         * YAHOO.util.DragDropMgr.refreshCache({group1:true, group2:true});
         * </code>
         * @TODO this really should be an indexed array.  Alternatively this
         * method could accept both.
         * @method refreshCache
         * @param {Object} groups an associative array of groups to refresh
         * @static
         */
        refreshCache: function(groups) {

            // refresh everything if group array is not provided
            var g = groups || this.ids;

            for (var sGroup in g) {
                if ("string" != typeof sGroup) {
                    continue;
                }
                for (var i in this.ids[sGroup]) {
                    var oDD = this.ids[sGroup][i];

                    if (this.isTypeOfDD(oDD)) {
                        var loc = this.getLocation(oDD);
                        if (loc) {
                            this.locationCache[oDD.id] = loc;
                        } else {
                            delete this.locationCache[oDD.id];
                        }
                    }
                }
            }
        },

        /**
         * This checks to make sure an element exists and is in the DOM.  The
         * main purpose is to handle cases where innerHTML is used to remove
         * drag and drop objects from the DOM.  IE provides an 'unspecified
         * error' when trying to access the offsetParent of such an element
         * @method verifyEl
         * @param {HTMLElement} el the element to check
         * @return {boolean} true if the element looks usable
         * @static
         */
        verifyEl: function(el) {
            try {
                if (el) {
                    var parent = el.offsetParent;
                    if (parent) {
                        return true;
                    }
                }
            } catch(e) {
            }

            return false;
        },
        
        /**
         * Returns a Region object containing the drag and drop element's position
         * and size, including the padding configured for it
         * @method getLocation
         * @param {DragDrop} oDD the drag and drop object to get the 
         *                       location for
         * @return {YAHOO.util.Region} a Region object representing the total area
         *                             the element occupies, including any padding
         *                             the instance is configured for.
         * @static
         */
        getLocation: function(oDD) {
            if (! this.isTypeOfDD(oDD)) {
                return null;
            }

            var el = oDD.getEl(), pos, x1, x2, y1, y2, t, r, b, l;

            try {
                pos= YAHOO.util.Dom.getXY(el);
            } catch (e) { }

            if (!pos) {
                return null;
            }

            x1 = pos[0];
            x2 = x1 + el.offsetWidth;
            y1 = pos[1];
            y2 = y1 + el.offsetHeight;

            t = y1 - oDD.padding[0];
            r = x2 + oDD.padding[1];
            b = y2 + oDD.padding[2];
            l = x1 - oDD.padding[3];

            return new YAHOO.util.Region( t, r, b, l );
        },

        /**
         * Checks the cursor location to see if it over the target
         * @method isOverTarget
         * @param {YAHOO.util.Point} pt The point to evaluate
         * @param {DragDrop} oTarget the DragDrop object we are inspecting
         * @param {boolean} intersect true if we are in intersect mode
         * @param {YAHOO.util.Region} pre-cached location of the dragged element
         * @return {boolean} true if the mouse is over the target
         * @private
         * @static
         */
        isOverTarget: function(pt, oTarget, intersect, curRegion) {
            // use cache if available
            var loc = this.locationCache[oTarget.id];
            if (!loc || !this.useCache) {
                loc = this.getLocation(oTarget);
                this.locationCache[oTarget.id] = loc;

            }

            if (!loc) {
                return false;
            }

            oTarget.cursorIsOver = loc.contains( pt );

            // DragDrop is using this as a sanity check for the initial mousedown
            // in this case we are done.  In POINT mode, if the drag obj has no
            // contraints, we are done. Otherwise we need to evaluate the 
            // region the target as occupies to determine if the dragged element
            // overlaps with it.
            
            var dc = this.dragCurrent;
            if (!dc || (!intersect && !dc.constrainX && !dc.constrainY)) {

                //if (oTarget.cursorIsOver) {
                //}
                return oTarget.cursorIsOver;
            }

            oTarget.overlap = null;


            // Get the current location of the drag element, this is the
            // location of the mouse event less the delta that represents
            // where the original mousedown happened on the element.  We
            // need to consider constraints and ticks as well.

            if (!curRegion) {
                var pos = dc.getTargetCoord(pt.x, pt.y);
                var el = dc.getDragEl();
                curRegion = new YAHOO.util.Region( pos.y, 
                                                   pos.x + el.offsetWidth,
                                                   pos.y + el.offsetHeight, 
                                                   pos.x );
            }

            var overlap = curRegion.intersect(loc);

            if (overlap) {
                oTarget.overlap = overlap;
                return (intersect) ? true : oTarget.cursorIsOver;
            } else {
                return false;
            }
        },

        /**
         * unload event handler
         * @method _onUnload
         * @private
         * @static
         */
        _onUnload: function(e, me) {
            this.unregAll();
        },

        /**
         * Cleans up the drag and drop events and objects.
         * @method unregAll
         * @private
         * @static
         */
        unregAll: function() {

            if (this.dragCurrent) {
                this.stopDrag();
                this.dragCurrent = null;
            }

            this._execOnAll("unreg", []);

            //for (var i in this.elementCache) {
                //delete this.elementCache[i];
            //}
            //this.elementCache = {};

            this.ids = {};
        },

        /**
         * A cache of DOM elements
         * @property elementCache
         * @private
         * @static
         * @deprecated elements are not cached now
         */
        elementCache: {},
        
        /**
         * Get the wrapper for the DOM element specified
         * @method getElWrapper
         * @param {String} id the id of the element to get
         * @return {YAHOO.util.DDM.ElementWrapper} the wrapped element
         * @private
         * @deprecated This wrapper isn't that useful
         * @static
         */
        getElWrapper: function(id) {
            var oWrapper = this.elementCache[id];
            if (!oWrapper || !oWrapper.el) {
                oWrapper = this.elementCache[id] = 
                    new this.ElementWrapper(YAHOO.util.Dom.get(id));
            }
            return oWrapper;
        },

        /**
         * Returns the actual DOM element
         * @method getElement
         * @param {String} id the id of the elment to get
         * @return {Object} The element
         * @deprecated use YAHOO.util.Dom.get instead
         * @static
         */
        getElement: function(id) {
            return YAHOO.util.Dom.get(id);
        },
        
        /**
         * Returns the style property for the DOM element (i.e., 
         * document.getElById(id).style)
         * @method getCss
         * @param {String} id the id of the elment to get
         * @return {Object} The style property of the element
         * @deprecated use YAHOO.util.Dom instead
         * @static
         */
        getCss: function(id) {
            var el = YAHOO.util.Dom.get(id);
            return (el) ? el.style : null;
        },

        /**
         * Inner class for cached elements
         * @class DragDropMgr.ElementWrapper
         * @for DragDropMgr
         * @private
         * @deprecated
         */
        ElementWrapper: function(el) {
                /**
                 * The element
                 * @property el
                 */
                this.el = el || null;
                /**
                 * The element id
                 * @property id
                 */
                this.id = this.el && el.id;
                /**
                 * A reference to the style property
                 * @property css
                 */
                this.css = this.el && el.style;
            },

        /**
         * Returns the X position of an html element
         * @method getPosX
         * @param el the element for which to get the position
         * @return {int} the X coordinate
         * @for DragDropMgr
         * @deprecated use YAHOO.util.Dom.getX instead
         * @static
         */
        getPosX: function(el) {
            return YAHOO.util.Dom.getX(el);
        },

        /**
         * Returns the Y position of an html element
         * @method getPosY
         * @param el the element for which to get the position
         * @return {int} the Y coordinate
         * @deprecated use YAHOO.util.Dom.getY instead
         * @static
         */
        getPosY: function(el) {
            return YAHOO.util.Dom.getY(el); 
        },

        /**
         * Swap two nodes.  In IE, we use the native method, for others we 
         * emulate the IE behavior
         * @method swapNode
         * @param n1 the first node to swap
         * @param n2 the other node to swap
         * @static
         */
        swapNode: function(n1, n2) {
            if (n1.swapNode) {
                n1.swapNode(n2);
            } else {
                var p = n2.parentNode;
                var s = n2.nextSibling;

                if (s == n1) {
                    p.insertBefore(n1, n2);
                } else if (n2 == n1.nextSibling) {
                    p.insertBefore(n2, n1);
                } else {
                    n1.parentNode.replaceChild(n2, n1);
                    p.insertBefore(n1, s);
                }
            }
        },

        /**
         * Returns the current scroll position
         * @method getScroll
         * @private
         * @static
         */
        getScroll: function () {
            var t, l, dde=document.documentElement, db=document.body;
            if (dde && (dde.scrollTop || dde.scrollLeft)) {
                t = dde.scrollTop;
                l = dde.scrollLeft;
            } else if (db) {
                t = db.scrollTop;
                l = db.scrollLeft;
            } else {
            }
            return { top: t, left: l };
        },

        /**
         * Returns the specified element style property
         * @method getStyle
         * @param {HTMLElement} el          the element
         * @param {string}      styleProp   the style property
         * @return {string} The value of the style property
         * @deprecated use YAHOO.util.Dom.getStyle
         * @static
         */
        getStyle: function(el, styleProp) {
            return YAHOO.util.Dom.getStyle(el, styleProp);
        },

        /**
         * Gets the scrollTop
         * @method getScrollTop
         * @return {int} the document's scrollTop
         * @static
         */
        getScrollTop: function () { return this.getScroll().top; },

        /**
         * Gets the scrollLeft
         * @method getScrollLeft
         * @return {int} the document's scrollTop
         * @static
         */
        getScrollLeft: function () { return this.getScroll().left; },

        /**
         * Sets the x/y position of an element to the location of the
         * target element.
         * @method moveToEl
         * @param {HTMLElement} moveEl      The element to move
         * @param {HTMLElement} targetEl    The position reference element
         * @static
         */
        moveToEl: function (moveEl, targetEl) {
            var aCoord = YAHOO.util.Dom.getXY(targetEl);
            YAHOO.util.Dom.setXY(moveEl, aCoord);
        },

        /**
         * Gets the client height
         * @method getClientHeight
         * @return {int} client height in px
         * @deprecated use YAHOO.util.Dom.getViewportHeight instead
         * @static
         */
        getClientHeight: function() {
            return YAHOO.util.Dom.getViewportHeight();
        },

        /**
         * Gets the client width
         * @method getClientWidth
         * @return {int} client width in px
         * @deprecated use YAHOO.util.Dom.getViewportWidth instead
         * @static
         */
        getClientWidth: function() {
            return YAHOO.util.Dom.getViewportWidth();
        },

        /**
         * Numeric array sort function
         * @method numericSort
         * @static
         */
        numericSort: function(a, b) { return (a - b); },

        /**
         * Internal counter
         * @property _timeoutCount
         * @private
         * @static
         */
        _timeoutCount: 0,

        /**
         * Trying to make the load order less important.  Without this we get
         * an error if this file is loaded before the Event Utility.
         * @method _addListeners
         * @private
         * @static
         */
        _addListeners: function() {
            var DDM = YAHOO.util.DDM;
            if ( YAHOO.util.Event && document ) {
                DDM._onLoad();
            } else {
                if (DDM._timeoutCount > 2000) {
                } else {
                    setTimeout(DDM._addListeners, 10);
                    if (document && document.body) {
                        DDM._timeoutCount += 1;
                    }
                }
            }
        },

        /**
         * Recursively searches the immediate parent and all child nodes for 
         * the handle element in order to determine wheter or not it was 
         * clicked.
         * @method handleWasClicked
         * @param node the html element to inspect
         * @static
         */
        handleWasClicked: function(node, id) {
            if (this.isHandle(id, node.id)) {
                return true;
            } else {
                // check to see if this is a text node child of the one we want
                var p = node.parentNode;

                while (p) {
                    if (this.isHandle(id, p.id)) {
                        return true;
                    } else {
                        p = p.parentNode;
                    }
                }
            }

            return false;
        }

    };

}();

// shorter alias, save a few bytes
YAHOO.util.DDM = YAHOO.util.DragDropMgr;
YAHOO.util.DDM._addListeners();

}

(function() {

var Event=YAHOO.util.Event; 
var Dom=YAHOO.util.Dom;

/**
 * Defines the interface and base operation of items that that can be 
 * dragged or can be drop targets.  It was designed to be extended, overriding
 * the event handlers for startDrag, onDrag, onDragOver, onDragOut.
 * Up to three html elements can be associated with a DragDrop instance:
 * <ul>
 * <li>linked element: the element that is passed into the constructor.
 * This is the element which defines the boundaries for interaction with 
 * other DragDrop objects.</li>
 * <li>handle element(s): The drag operation only occurs if the element that 
 * was clicked matches a handle element.  By default this is the linked 
 * element, but there are times that you will want only a portion of the 
 * linked element to initiate the drag operation, and the setHandleElId() 
 * method provides a way to define this.</li>
 * <li>drag element: this represents an the element that would be moved along
 * with the cursor during a drag operation.  By default, this is the linked
 * element itself as in {@link YAHOO.util.DD}.  setDragElId() lets you define
 * a separate element that would be moved, as in {@link YAHOO.util.DDProxy}
 * </li>
 * </ul>
 * This class should not be instantiated until the onload event to ensure that
 * the associated elements are available.
 * The following would define a DragDrop obj that would interact with any 
 * other DragDrop obj in the "group1" group:
 * <pre>
 *  dd = new YAHOO.util.DragDrop("div1", "group1");
 * </pre>
 * Since none of the event handlers have been implemented, nothing would 
 * actually happen if you were to run the code above.  Normally you would 
 * override this class or one of the default implementations, but you can 
 * also override the methods you want on an instance of the class...
 * <pre>
 *  dd.onDragDrop = function(e, id) {
 *  &nbsp;&nbsp;alert("dd was dropped on " + id);
 *  }
 * </pre>
 * @namespace YAHOO.util
 * @class DragDrop
 * @constructor
 * @param {String} id of the element that is linked to this instance
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DragDrop: 
 *                    padding, isTarget, maintainOffset, primaryButtonOnly,
 */
YAHOO.util.DragDrop = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config); 
    }
};

YAHOO.util.DragDrop.prototype = {
    /**
     * An Object Literal containing the events that we will be using: mouseDown, b4MouseDown, mouseUp, b4StartDrag, startDrag, b4EndDrag, endDrag, mouseUp, drag, b4Drag, invalidDrop, b4DragOut, dragOut, dragEnter, b4DragOver, dragOver, b4DragDrop, dragDrop
     * By setting any of these to false, then event will not be fired.
     * @property events
     * @type object
     */
    events: null,
    /**
    * @method on
    * @description Shortcut for EventProvider.subscribe, see <a href="YAHOO.util.EventProvider.html#subscribe">YAHOO.util.EventProvider.subscribe</a>
    */
    on: function() {
        this.subscribe.apply(this, arguments);
    },
    /**
     * The id of the element associated with this object.  This is what we 
     * refer to as the "linked element" because the size and position of 
     * this element is used to determine when the drag and drop objects have 
     * interacted.
     * @property id
     * @type String
     */
    id: null,

    /**
     * Configuration attributes passed into the constructor
     * @property config
     * @type object
     */
    config: null,

    /**
     * The id of the element that will be dragged.  By default this is same 
     * as the linked element , but could be changed to another element. Ex: 
     * YAHOO.util.DDProxy
     * @property dragElId
     * @type String
     * @private
     */
    dragElId: null, 

    /**
     * the id of the element that initiates the drag operation.  By default 
     * this is the linked element, but could be changed to be a child of this
     * element.  This lets us do things like only starting the drag when the 
     * header element within the linked html element is clicked.
     * @property handleElId
     * @type String
     * @private
     */
    handleElId: null, 

    /**
     * An associative array of HTML tags that will be ignored if clicked.
     * @property invalidHandleTypes
     * @type {string: string}
     */
    invalidHandleTypes: null, 

    /**
     * An associative array of ids for elements that will be ignored if clicked
     * @property invalidHandleIds
     * @type {string: string}
     */
    invalidHandleIds: null, 

    /**
     * An indexted array of css class names for elements that will be ignored
     * if clicked.
     * @property invalidHandleClasses
     * @type string[]
     */
    invalidHandleClasses: null, 

    /**
     * The linked element's absolute X position at the time the drag was 
     * started
     * @property startPageX
     * @type int
     * @private
     */
    startPageX: 0,

    /**
     * The linked element's absolute X position at the time the drag was 
     * started
     * @property startPageY
     * @type int
     * @private
     */
    startPageY: 0,

    /**
     * The group defines a logical collection of DragDrop objects that are 
     * related.  Instances only get events when interacting with other 
     * DragDrop object in the same group.  This lets us define multiple 
     * groups using a single DragDrop subclass if we want.
     * @property groups
     * @type {string: string}
     */
    groups: null,

    /**
     * Individual drag/drop instances can be locked.  This will prevent 
     * onmousedown start drag.
     * @property locked
     * @type boolean
     * @private
     */
    locked: false,

    /**
     * Lock this instance
     * @method lock
     */
    lock: function() { this.locked = true; },

    /**
     * Unlock this instace
     * @method unlock
     */
    unlock: function() { this.locked = false; },

    /**
     * By default, all instances can be a drop target.  This can be disabled by
     * setting isTarget to false.
     * @property isTarget
     * @type boolean
     */
    isTarget: true,

    /**
     * The padding configured for this drag and drop object for calculating
     * the drop zone intersection with this object.
     * @property padding
     * @type int[]
     */
    padding: null,
    /**
     * If this flag is true, do not fire drop events. The element is a drag only element (for movement not dropping)
     * @property dragOnly
     * @type Boolean
     */
    dragOnly: false,

    /**
     * If this flag is true, a shim will be placed over the screen/viewable area to track mouse events. Should help with dragging elements over iframes and other controls.
     * @property useShim
     * @type Boolean
     */
    useShim: false,

    /**
     * Cached reference to the linked element
     * @property _domRef
     * @private
     */
    _domRef: null,

    /**
     * Internal typeof flag
     * @property __ygDragDrop
     * @private
     */
    __ygDragDrop: true,

    /**
     * Set to true when horizontal contraints are applied
     * @property constrainX
     * @type boolean
     * @private
     */
    constrainX: false,

    /**
     * Set to true when vertical contraints are applied
     * @property constrainY
     * @type boolean
     * @private
     */
    constrainY: false,

    /**
     * The left constraint
     * @property minX
     * @type int
     * @private
     */
    minX: 0,

    /**
     * The right constraint
     * @property maxX
     * @type int
     * @private
     */
    maxX: 0,

    /**
     * The up constraint 
     * @property minY
     * @type int
     * @type int
     * @private
     */
    minY: 0,

    /**
     * The down constraint 
     * @property maxY
     * @type int
     * @private
     */
    maxY: 0,

    /**
     * The difference between the click position and the source element's location
     * @property deltaX
     * @type int
     * @private
     */
    deltaX: 0,

    /**
     * The difference between the click position and the source element's location
     * @property deltaY
     * @type int
     * @private
     */
    deltaY: 0,

    /**
     * Maintain offsets when we resetconstraints.  Set to true when you want
     * the position of the element relative to its parent to stay the same
     * when the page changes
     *
     * @property maintainOffset
     * @type boolean
     */
    maintainOffset: false,

    /**
     * Array of pixel locations the element will snap to if we specified a 
     * horizontal graduation/interval.  This array is generated automatically
     * when you define a tick interval.
     * @property xTicks
     * @type int[]
     */
    xTicks: null,

    /**
     * Array of pixel locations the element will snap to if we specified a 
     * vertical graduation/interval.  This array is generated automatically 
     * when you define a tick interval.
     * @property yTicks
     * @type int[]
     */
    yTicks: null,

    /**
     * By default the drag and drop instance will only respond to the primary
     * button click (left button for a right-handed mouse).  Set to true to
     * allow drag and drop to start with any mouse click that is propogated
     * by the browser
     * @property primaryButtonOnly
     * @type boolean
     */
    primaryButtonOnly: true,

    /**
     * The availabe property is false until the linked dom element is accessible.
     * @property available
     * @type boolean
     */
    available: false,

    /**
     * By default, drags can only be initiated if the mousedown occurs in the
     * region the linked element is.  This is done in part to work around a
     * bug in some browsers that mis-report the mousedown if the previous
     * mouseup happened outside of the window.  This property is set to true
     * if outer handles are defined.
     *
     * @property hasOuterHandles
     * @type boolean
     * @default false
     */
    hasOuterHandles: false,

    /**
     * Property that is assigned to a drag and drop object when testing to
     * see if it is being targeted by another dd object.  This property
     * can be used in intersect mode to help determine the focus of
     * the mouse interaction.  DDM.getBestMatch uses this property first to
     * determine the closest match in INTERSECT mode when multiple targets
     * are part of the same interaction.
     * @property cursorIsOver
     * @type boolean
     */
    cursorIsOver: false,

    /**
     * Property that is assigned to a drag and drop object when testing to
     * see if it is being targeted by another dd object.  This is a region
     * that represents the area the draggable element overlaps this target.
     * DDM.getBestMatch uses this property to compare the size of the overlap
     * to that of other targets in order to determine the closest match in
     * INTERSECT mode when multiple targets are part of the same interaction.
     * @property overlap 
     * @type YAHOO.util.Region
     */
    overlap: null,

    /**
     * Code that executes immediately before the startDrag event
     * @method b4StartDrag
     * @private
     */
    b4StartDrag: function(x, y) { },

    /**
     * Abstract method called after a drag/drop object is clicked
     * and the drag or mousedown time thresholds have beeen met.
     * @method startDrag
     * @param {int} X click location
     * @param {int} Y click location
     */
    startDrag: function(x, y) { /* override this */ },

    /**
     * Code that executes immediately before the onDrag event
     * @method b4Drag
     * @private
     */
    b4Drag: function(e) { },

    /**
     * Abstract method called during the onMouseMove event while dragging an 
     * object.
     * @method onDrag
     * @param {Event} e the mousemove event
     */
    onDrag: function(e) { /* override this */ },

    /**
     * Abstract method called when this element fist begins hovering over 
     * another DragDrop obj
     * @method onDragEnter
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of one or more 
     * dragdrop items being hovered over.
     */
    onDragEnter: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragOver event
     * @method b4DragOver
     * @private
     */
    b4DragOver: function(e) { },

    /**
     * Abstract method called when this element is hovering over another 
     * DragDrop obj
     * @method onDragOver
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this is hovering over.  In INTERSECT mode, an array of dd items 
     * being hovered over.
     */
    onDragOver: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragOut event
     * @method b4DragOut
     * @private
     */
    b4DragOut: function(e) { },

    /**
     * Abstract method called when we are no longer hovering over an element
     * @method onDragOut
     * @param {Event} e the mousemove event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was hovering over.  In INTERSECT mode, an array of dd items 
     * that the mouse is no longer over.
     */
    onDragOut: function(e, id) { /* override this */ },

    /**
     * Code that executes immediately before the onDragDrop event
     * @method b4DragDrop
     * @private
     */
    b4DragDrop: function(e) { },

    /**
     * Abstract method called when this item is dropped on another DragDrop 
     * obj
     * @method onDragDrop
     * @param {Event} e the mouseup event
     * @param {String|DragDrop[]} id In POINT mode, the element
     * id this was dropped on.  In INTERSECT mode, an array of dd items this 
     * was dropped on.
     */
    onDragDrop: function(e, id) { /* override this */ },

    /**
     * Abstract method called when this item is dropped on an area with no
     * drop target
     * @method onInvalidDrop
     * @param {Event} e the mouseup event
     */
    onInvalidDrop: function(e) { /* override this */ },

    /**
     * Code that executes immediately before the endDrag event
     * @method b4EndDrag
     * @private
     */
    b4EndDrag: function(e) { },

    /**
     * Fired when we are done dragging the object
     * @method endDrag
     * @param {Event} e the mouseup event
     */
    endDrag: function(e) { /* override this */ },

    /**
     * Code executed immediately before the onMouseDown event
     * @method b4MouseDown
     * @param {Event} e the mousedown event
     * @private
     */
    b4MouseDown: function(e) {  },

    /**
     * Event handler that fires when a drag/drop obj gets a mousedown
     * @method onMouseDown
     * @param {Event} e the mousedown event
     */
    onMouseDown: function(e) { /* override this */ },

    /**
     * Event handler that fires when a drag/drop obj gets a mouseup
     * @method onMouseUp
     * @param {Event} e the mouseup event
     */
    onMouseUp: function(e) { /* override this */ },
   
    /**
     * Override the onAvailable method to do what is needed after the initial
     * position was determined.
     * @method onAvailable
     */
    onAvailable: function () { 
    },

    /**
     * Returns a reference to the linked element
     * @method getEl
     * @return {HTMLElement} the html element 
     */
    getEl: function() { 
        if (!this._domRef) {
            this._domRef = Dom.get(this.id); 
        }

        return this._domRef;
    },

    /**
     * Returns a reference to the actual element to drag.  By default this is
     * the same as the html element, but it can be assigned to another 
     * element. An example of this can be found in YAHOO.util.DDProxy
     * @method getDragEl
     * @return {HTMLElement} the html element 
     */
    getDragEl: function() {
        return Dom.get(this.dragElId);
    },

    /**
     * Sets up the DragDrop object.  Must be called in the constructor of any
     * YAHOO.util.DragDrop subclass
     * @method init
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    init: function(id, sGroup, config) {
        this.initTarget(id, sGroup, config);
        Event.on(this._domRef || this.id, "mousedown", 
                        this.handleMouseDown, this, true);

        // Event.on(this.id, "selectstart", Event.preventDefault);
        for (var i in this.events) {
            this.createEvent(i + 'Event');
        }
        
    },

    /**
     * Initializes Targeting functionality only... the object does not
     * get a mousedown handler.
     * @method initTarget
     * @param id the id of the linked element
     * @param {String} sGroup the group of related items
     * @param {object} config configuration attributes
     */
    initTarget: function(id, sGroup, config) {

        // configuration attributes 
        this.config = config || {};

        this.events = {};

        // create a local reference to the drag and drop manager
        this.DDM = YAHOO.util.DDM;

        // initialize the groups object
        this.groups = {};

        // assume that we have an element reference instead of an id if the
        // parameter is not a string
        if (typeof id !== "string") {
            this._domRef = id;
            id = Dom.generateId(id);
        }

        // set the id
        this.id = id;

        // add to an interaction group
        this.addToGroup((sGroup) ? sGroup : "default");

        // We don't want to register this as the handle with the manager
        // so we just set the id rather than calling the setter.
        this.handleElId = id;

        Event.onAvailable(id, this.handleOnAvailable, this, true);


        // the linked element is the element that gets dragged by default
        this.setDragElId(id); 

        // by default, clicked anchors will not start drag operations. 
        // @TODO what else should be here?  Probably form fields.
        this.invalidHandleTypes = { A: "A" };
        this.invalidHandleIds = {};
        this.invalidHandleClasses = [];

        this.applyConfig();
    },

    /**
     * Applies the configuration parameters that were passed into the constructor.
     * This is supposed to happen at each level through the inheritance chain.  So
     * a DDProxy implentation will execute apply config on DDProxy, DD, and 
     * DragDrop in order to get all of the parameters that are available in
     * each object.
     * @method applyConfig
     */
    applyConfig: function() {
        this.events = {
            mouseDown: true,
            b4MouseDown: true,
            mouseUp: true,
            b4StartDrag: true,
            startDrag: true,
            b4EndDrag: true,
            endDrag: true,
            drag: true,
            b4Drag: true,
            invalidDrop: true,
            b4DragOut: true,
            dragOut: true,
            dragEnter: true,
            b4DragOver: true,
            dragOver: true,
            b4DragDrop: true,
            dragDrop: true
        };
        
        if (this.config.events) {
            for (var i in this.config.events) {
                if (this.config.events[i] === false) {
                    this.events[i] = false;
                }
            }
        }


        // configurable properties: 
        //    padding, isTarget, maintainOffset, primaryButtonOnly
        this.padding           = this.config.padding || [0, 0, 0, 0];
        this.isTarget          = (this.config.isTarget !== false);
        this.maintainOffset    = (this.config.maintainOffset);
        this.primaryButtonOnly = (this.config.primaryButtonOnly !== false);
        this.dragOnly = ((this.config.dragOnly === true) ? true : false);
        this.useShim = ((this.config.useShim === true) ? true : false);
    },

    /**
     * Executed when the linked element is available
     * @method handleOnAvailable
     * @private
     */
    handleOnAvailable: function() {
        this.available = true;
        this.resetConstraints();
        this.onAvailable();
    },

     /**
     * Configures the padding for the target zone in px.  Effectively expands
     * (or reduces) the virtual object size for targeting calculations.  
     * Supports css-style shorthand; if only one parameter is passed, all sides
     * will have that padding, and if only two are passed, the top and bottom
     * will have the first param, the left and right the second.
     * @method setPadding
     * @param {int} iTop    Top pad
     * @param {int} iRight  Right pad
     * @param {int} iBot    Bot pad
     * @param {int} iLeft   Left pad
     */
    setPadding: function(iTop, iRight, iBot, iLeft) {
        // this.padding = [iLeft, iRight, iTop, iBot];
        if (!iRight && 0 !== iRight) {
            this.padding = [iTop, iTop, iTop, iTop];
        } else if (!iBot && 0 !== iBot) {
            this.padding = [iTop, iRight, iTop, iRight];
        } else {
            this.padding = [iTop, iRight, iBot, iLeft];
        }
    },

    /**
     * Stores the initial placement of the linked element.
     * @method setInitialPosition
     * @param {int} diffX   the X offset, default 0
     * @param {int} diffY   the Y offset, default 0
     * @private
     */
    setInitPosition: function(diffX, diffY) {
        var el = this.getEl();

        if (!this.DDM.verifyEl(el)) {
            if (el && el.style && (el.style.display == 'none')) {
            } else {
            }
            return;
        }

        var dx = diffX || 0;
        var dy = diffY || 0;

        var p = Dom.getXY( el );

        this.initPageX = p[0] - dx;
        this.initPageY = p[1] - dy;

        this.lastPageX = p[0];
        this.lastPageY = p[1];



        this.setStartPosition(p);
    },

    /**
     * Sets the start position of the element.  This is set when the obj
     * is initialized, the reset when a drag is started.
     * @method setStartPosition
     * @param pos current position (from previous lookup)
     * @private
     */
    setStartPosition: function(pos) {
        var p = pos || Dom.getXY(this.getEl());

        this.deltaSetXY = null;

        this.startPageX = p[0];
        this.startPageY = p[1];
    },

    /**
     * Add this instance to a group of related drag/drop objects.  All 
     * instances belong to at least one group, and can belong to as many 
     * groups as needed.
     * @method addToGroup
     * @param sGroup {string} the name of the group
     */
    addToGroup: function(sGroup) {
        this.groups[sGroup] = true;
        this.DDM.regDragDrop(this, sGroup);
    },

    /**
     * Remove's this instance from the supplied interaction group
     * @method removeFromGroup
     * @param {string}  sGroup  The group to drop
     */
    removeFromGroup: function(sGroup) {
        if (this.groups[sGroup]) {
            delete this.groups[sGroup];
        }

        this.DDM.removeDDFromGroup(this, sGroup);
    },

    /**
     * Allows you to specify that an element other than the linked element 
     * will be moved with the cursor during a drag
     * @method setDragElId
     * @param id {string} the id of the element that will be used to initiate the drag
     */
    setDragElId: function(id) {
        this.dragElId = id;
    },

    /**
     * Allows you to specify a child of the linked element that should be 
     * used to initiate the drag operation.  An example of this would be if 
     * you have a content div with text and links.  Clicking anywhere in the 
     * content area would normally start the drag operation.  Use this method
     * to specify that an element inside of the content div is the element 
     * that starts the drag operation.
     * @method setHandleElId
     * @param id {string} the id of the element that will be used to 
     * initiate the drag.
     */
    setHandleElId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        this.handleElId = id;
        this.DDM.regHandle(this.id, id);
    },

    /**
     * Allows you to set an element outside of the linked element as a drag 
     * handle
     * @method setOuterHandleElId
     * @param id the id of the element that will be used to initiate the drag
     */
    setOuterHandleElId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        Event.on(id, "mousedown", 
                this.handleMouseDown, this, true);
        this.setHandleElId(id);

        this.hasOuterHandles = true;
    },

    /**
     * Remove all drag and drop hooks for this element
     * @method unreg
     */
    unreg: function() {
        Event.removeListener(this.id, "mousedown", 
                this.handleMouseDown);
        this._domRef = null;
        this.DDM._remove(this);
    },

    /**
     * Returns true if this instance is locked, or the drag drop mgr is locked
     * (meaning that all drag/drop is disabled on the page.)
     * @method isLocked
     * @return {boolean} true if this obj or all drag/drop is locked, else 
     * false
     */
    isLocked: function() {
        return (this.DDM.isLocked() || this.locked);
    },

    /**
     * Fired when this object is clicked
     * @method handleMouseDown
     * @param {Event} e 
     * @param {YAHOO.util.DragDrop} oDD the clicked dd object (this dd obj)
     * @private
     */
    handleMouseDown: function(e, oDD) {

        var button = e.which || e.button;

        if (this.primaryButtonOnly && button > 1) {
            return;
        }

        if (this.isLocked()) {
            return;
        }



        // firing the mousedown events prior to calculating positions
        var b4Return = this.b4MouseDown(e),
        b4Return2 = true;

        if (this.events.b4MouseDown) {
            b4Return2 = this.fireEvent('b4MouseDownEvent', e);
        }
        var mDownReturn = this.onMouseDown(e),
            mDownReturn2 = true;
        if (this.events.mouseDown) {
            mDownReturn2 = this.fireEvent('mouseDownEvent', e);
        }

        if ((b4Return === false) || (mDownReturn === false) || (b4Return2 === false) || (mDownReturn2 === false)) {
            return;
        }

        this.DDM.refreshCache(this.groups);
        // var self = this;
        // setTimeout( function() { self.DDM.refreshCache(self.groups); }, 0);

        // Only process the event if we really clicked within the linked 
        // element.  The reason we make this check is that in the case that 
        // another element was moved between the clicked element and the 
        // cursor in the time between the mousedown and mouseup events. When 
        // this happens, the element gets the next mousedown event 
        // regardless of where on the screen it happened.  
        var pt = new YAHOO.util.Point(Event.getPageX(e), Event.getPageY(e));
        if (!this.hasOuterHandles && !this.DDM.isOverTarget(pt, this) )  {
        } else {
            if (this.clickValidator(e)) {


                // set the initial element position
                this.setStartPosition();

                // start tracking mousemove distance and mousedown time to
                // determine when to start the actual drag
                this.DDM.handleMouseDown(e, this);

                // this mousedown is mine
                this.DDM.stopEvent(e);
            } else {


            }
        }
    },

    /**
     * @method clickValidator
     * @description Method validates that the clicked element
     * was indeed the handle or a valid child of the handle
     * @param {Event} e 
     */
    clickValidator: function(e) {
        var target = YAHOO.util.Event.getTarget(e);
        return ( this.isValidHandleChild(target) &&
                    (this.id == this.handleElId || 
                        this.DDM.handleWasClicked(target, this.id)) );
    },

    /**
     * Finds the location the element should be placed if we want to move
     * it to where the mouse location less the click offset would place us.
     * @method getTargetCoord
     * @param {int} iPageX the X coordinate of the click
     * @param {int} iPageY the Y coordinate of the click
     * @return an object that contains the coordinates (Object.x and Object.y)
     * @private
     */
    getTargetCoord: function(iPageX, iPageY) {


        var x = iPageX - this.deltaX;
        var y = iPageY - this.deltaY;

        if (this.constrainX) {
            if (x < this.minX) { x = this.minX; }
            if (x > this.maxX) { x = this.maxX; }
        }

        if (this.constrainY) {
            if (y < this.minY) { y = this.minY; }
            if (y > this.maxY) { y = this.maxY; }
        }

        x = this.getTick(x, this.xTicks);
        y = this.getTick(y, this.yTicks);


        return {x:x, y:y};
    },

    /**
     * Allows you to specify a tag name that should not start a drag operation
     * when clicked.  This is designed to facilitate embedding links within a
     * drag handle that do something other than start the drag.
     * @method addInvalidHandleType
     * @param {string} tagName the type of element to exclude
     */
    addInvalidHandleType: function(tagName) {
        var type = tagName.toUpperCase();
        this.invalidHandleTypes[type] = type;
    },

    /**
     * Lets you to specify an element id for a child of a drag handle
     * that should not initiate a drag
     * @method addInvalidHandleId
     * @param {string} id the element id of the element you wish to ignore
     */
    addInvalidHandleId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        this.invalidHandleIds[id] = id;
    },


    /**
     * Lets you specify a css class of elements that will not initiate a drag
     * @method addInvalidHandleClass
     * @param {string} cssClass the class of the elements you wish to ignore
     */
    addInvalidHandleClass: function(cssClass) {
        this.invalidHandleClasses.push(cssClass);
    },

    /**
     * Unsets an excluded tag name set by addInvalidHandleType
     * @method removeInvalidHandleType
     * @param {string} tagName the type of element to unexclude
     */
    removeInvalidHandleType: function(tagName) {
        var type = tagName.toUpperCase();
        // this.invalidHandleTypes[type] = null;
        delete this.invalidHandleTypes[type];
    },
    
    /**
     * Unsets an invalid handle id
     * @method removeInvalidHandleId
     * @param {string} id the id of the element to re-enable
     */
    removeInvalidHandleId: function(id) {
        if (typeof id !== "string") {
            id = Dom.generateId(id);
        }
        delete this.invalidHandleIds[id];
    },

    /**
     * Unsets an invalid css class
     * @method removeInvalidHandleClass
     * @param {string} cssClass the class of the element(s) you wish to 
     * re-enable
     */
    removeInvalidHandleClass: function(cssClass) {
        for (var i=0, len=this.invalidHandleClasses.length; i<len; ++i) {
            if (this.invalidHandleClasses[i] == cssClass) {
                delete this.invalidHandleClasses[i];
            }
        }
    },

    /**
     * Checks the tag exclusion list to see if this click should be ignored
     * @method isValidHandleChild
     * @param {HTMLElement} node the HTMLElement to evaluate
     * @return {boolean} true if this is a valid tag type, false if not
     */
    isValidHandleChild: function(node) {

        var valid = true;
        // var n = (node.nodeName == "#text") ? node.parentNode : node;
        var nodeName;
        try {
            nodeName = node.nodeName.toUpperCase();
        } catch(e) {
            nodeName = node.nodeName;
        }
        valid = valid && !this.invalidHandleTypes[nodeName];
        valid = valid && !this.invalidHandleIds[node.id];

        for (var i=0, len=this.invalidHandleClasses.length; valid && i<len; ++i) {
            valid = !Dom.hasClass(node, this.invalidHandleClasses[i]);
        }


        return valid;

    },

    /**
     * Create the array of horizontal tick marks if an interval was specified
     * in setXConstraint().
     * @method setXTicks
     * @private
     */
    setXTicks: function(iStartX, iTickSize) {
        this.xTicks = [];
        this.xTickSize = iTickSize;
        
        var tickMap = {};

        for (var i = this.initPageX; i >= this.minX; i = i - iTickSize) {
            if (!tickMap[i]) {
                this.xTicks[this.xTicks.length] = i;
                tickMap[i] = true;
            }
        }

        for (i = this.initPageX; i <= this.maxX; i = i + iTickSize) {
            if (!tickMap[i]) {
                this.xTicks[this.xTicks.length] = i;
                tickMap[i] = true;
            }
        }

        this.xTicks.sort(this.DDM.numericSort) ;
    },

    /**
     * Create the array of vertical tick marks if an interval was specified in 
     * setYConstraint().
     * @method setYTicks
     * @private
     */
    setYTicks: function(iStartY, iTickSize) {
        this.yTicks = [];
        this.yTickSize = iTickSize;

        var tickMap = {};

        for (var i = this.initPageY; i >= this.minY; i = i - iTickSize) {
            if (!tickMap[i]) {
                this.yTicks[this.yTicks.length] = i;
                tickMap[i] = true;
            }
        }

        for (i = this.initPageY; i <= this.maxY; i = i + iTickSize) {
            if (!tickMap[i]) {
                this.yTicks[this.yTicks.length] = i;
                tickMap[i] = true;
            }
        }

        this.yTicks.sort(this.DDM.numericSort) ;
    },

    /**
     * By default, the element can be dragged any place on the screen.  Use 
     * this method to limit the horizontal travel of the element.  Pass in 
     * 0,0 for the parameters if you want to lock the drag to the y axis.
     * @method setXConstraint
     * @param {int} iLeft the number of pixels the element can move to the left
     * @param {int} iRight the number of pixels the element can move to the 
     * right
     * @param {int} iTickSize optional parameter for specifying that the 
     * element
     * should move iTickSize pixels at a time.
     */
    setXConstraint: function(iLeft, iRight, iTickSize) {
        this.leftConstraint = parseInt(iLeft, 10);
        this.rightConstraint = parseInt(iRight, 10);

        this.minX = this.initPageX - this.leftConstraint;
        this.maxX = this.initPageX + this.rightConstraint;
        if (iTickSize) { this.setXTicks(this.initPageX, iTickSize); }

        this.constrainX = true;
    },

    /**
     * Clears any constraints applied to this instance.  Also clears ticks
     * since they can't exist independent of a constraint at this time.
     * @method clearConstraints
     */
    clearConstraints: function() {
        this.constrainX = false;
        this.constrainY = false;
        this.clearTicks();
    },

    /**
     * Clears any tick interval defined for this instance
     * @method clearTicks
     */
    clearTicks: function() {
        this.xTicks = null;
        this.yTicks = null;
        this.xTickSize = 0;
        this.yTickSize = 0;
    },

    /**
     * By default, the element can be dragged any place on the screen.  Set 
     * this to limit the vertical travel of the element.  Pass in 0,0 for the
     * parameters if you want to lock the drag to the x axis.
     * @method setYConstraint
     * @param {int} iUp the number of pixels the element can move up
     * @param {int} iDown the number of pixels the element can move down
     * @param {int} iTickSize optional parameter for specifying that the 
     * element should move iTickSize pixels at a time.
     */
    setYConstraint: function(iUp, iDown, iTickSize) {
        this.topConstraint = parseInt(iUp, 10);
        this.bottomConstraint = parseInt(iDown, 10);

        this.minY = this.initPageY - this.topConstraint;
        this.maxY = this.initPageY + this.bottomConstraint;
        if (iTickSize) { this.setYTicks(this.initPageY, iTickSize); }

        this.constrainY = true;
        
    },

    /**
     * resetConstraints must be called if you manually reposition a dd element.
     * @method resetConstraints
     */
    resetConstraints: function() {


        // Maintain offsets if necessary
        if (this.initPageX || this.initPageX === 0) {
            // figure out how much this thing has moved
            var dx = (this.maintainOffset) ? this.lastPageX - this.initPageX : 0;
            var dy = (this.maintainOffset) ? this.lastPageY - this.initPageY : 0;

            this.setInitPosition(dx, dy);

        // This is the first time we have detected the element's position
        } else {
            this.setInitPosition();
        }

        if (this.constrainX) {
            this.setXConstraint( this.leftConstraint, 
                                 this.rightConstraint, 
                                 this.xTickSize        );
        }

        if (this.constrainY) {
            this.setYConstraint( this.topConstraint, 
                                 this.bottomConstraint, 
                                 this.yTickSize         );
        }
    },

    /**
     * Normally the drag element is moved pixel by pixel, but we can specify 
     * that it move a number of pixels at a time.  This method resolves the 
     * location when we have it set up like this.
     * @method getTick
     * @param {int} val where we want to place the object
     * @param {int[]} tickArray sorted array of valid points
     * @return {int} the closest tick
     * @private
     */
    getTick: function(val, tickArray) {

        if (!tickArray) {
            // If tick interval is not defined, it is effectively 1 pixel, 
            // so we return the value passed to us.
            return val; 
        } else if (tickArray[0] >= val) {
            // The value is lower than the first tick, so we return the first
            // tick.
            return tickArray[0];
        } else {
            for (var i=0, len=tickArray.length; i<len; ++i) {
                var next = i + 1;
                if (tickArray[next] && tickArray[next] >= val) {
                    var diff1 = val - tickArray[i];
                    var diff2 = tickArray[next] - val;
                    return (diff2 > diff1) ? tickArray[i] : tickArray[next];
                }
            }

            // The value is larger than the last tick, so we return the last
            // tick.
            return tickArray[tickArray.length - 1];
        }
    },

    /**
     * toString method
     * @method toString
     * @return {string} string representation of the dd obj
     */
    toString: function() {
        return ("DragDrop " + this.id);
    }

};
YAHOO.augment(YAHOO.util.DragDrop, YAHOO.util.EventProvider);

/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent 
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
})();
/**
 * A DragDrop implementation where the linked element follows the 
 * mouse cursor during a drag.
 * @class DD
 * @extends YAHOO.util.DragDrop
 * @constructor
 * @param {String} id the id of the linked element 
 * @param {String} sGroup the group of related DragDrop items
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DD: 
 *                    scroll
 */
YAHOO.util.DD = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config);
    }
};

YAHOO.extend(YAHOO.util.DD, YAHOO.util.DragDrop, {

    /**
     * When set to true, the utility automatically tries to scroll the browser
     * window when a drag and drop element is dragged near the viewport boundary.
     * Defaults to true.
     * @property scroll
     * @type boolean
     */
    scroll: true, 

    /**
     * Sets the pointer offset to the distance between the linked element's top 
     * left corner and the location the element was clicked
     * @method autoOffset
     * @param {int} iPageX the X coordinate of the click
     * @param {int} iPageY the Y coordinate of the click
     */
    autoOffset: function(iPageX, iPageY) {
        var x = iPageX - this.startPageX;
        var y = iPageY - this.startPageY;
        this.setDelta(x, y);
    },

    /** 
     * Sets the pointer offset.  You can call this directly to force the 
     * offset to be in a particular location (e.g., pass in 0,0 to set it 
     * to the center of the object, as done in YAHOO.widget.Slider)
     * @method setDelta
     * @param {int} iDeltaX the distance from the left
     * @param {int} iDeltaY the distance from the top
     */
    setDelta: function(iDeltaX, iDeltaY) {
        this.deltaX = iDeltaX;
        this.deltaY = iDeltaY;
    },

    /**
     * Sets the drag element to the location of the mousedown or click event, 
     * maintaining the cursor location relative to the location on the element 
     * that was clicked.  Override this if you want to place the element in a 
     * location other than where the cursor is.
     * @method setDragElPos
     * @param {int} iPageX the X coordinate of the mousedown or drag event
     * @param {int} iPageY the Y coordinate of the mousedown or drag event
     */
    setDragElPos: function(iPageX, iPageY) {
        // the first time we do this, we are going to check to make sure
        // the element has css positioning

        var el = this.getDragEl();
        this.alignElWithMouse(el, iPageX, iPageY);
    },

    /**
     * Sets the element to the location of the mousedown or click event, 
     * maintaining the cursor location relative to the location on the element 
     * that was clicked.  Override this if you want to place the element in a 
     * location other than where the cursor is.
     * @method alignElWithMouse
     * @param {HTMLElement} el the element to move
     * @param {int} iPageX the X coordinate of the mousedown or drag event
     * @param {int} iPageY the Y coordinate of the mousedown or drag event
     */
    alignElWithMouse: function(el, iPageX, iPageY) {
        var oCoord = this.getTargetCoord(iPageX, iPageY);

        if (!this.deltaSetXY) {
            var aCoord = [oCoord.x, oCoord.y];
            YAHOO.util.Dom.setXY(el, aCoord);

            var newLeft = parseInt( YAHOO.util.Dom.getStyle(el, "left"), 10 );
            var newTop  = parseInt( YAHOO.util.Dom.getStyle(el, "top" ), 10 );

            this.deltaSetXY = [ newLeft - oCoord.x, newTop - oCoord.y ];
        } else {
            YAHOO.util.Dom.setStyle(el, "left", (oCoord.x + this.deltaSetXY[0]) + "px");
            YAHOO.util.Dom.setStyle(el, "top",  (oCoord.y + this.deltaSetXY[1]) + "px");
        }
        
        this.cachePosition(oCoord.x, oCoord.y);
        var self = this;
        setTimeout(function() {
            self.autoScroll.call(self, oCoord.x, oCoord.y, el.offsetHeight, el.offsetWidth);
        }, 0);
    },

    /**
     * Saves the most recent position so that we can reset the constraints and
     * tick marks on-demand.  We need to know this so that we can calculate the
     * number of pixels the element is offset from its original position.
     * @method cachePosition
     * @param iPageX the current x position (optional, this just makes it so we
     * don't have to look it up again)
     * @param iPageY the current y position (optional, this just makes it so we
     * don't have to look it up again)
     */
    cachePosition: function(iPageX, iPageY) {
        if (iPageX) {
            this.lastPageX = iPageX;
            this.lastPageY = iPageY;
        } else {
            var aCoord = YAHOO.util.Dom.getXY(this.getEl());
            this.lastPageX = aCoord[0];
            this.lastPageY = aCoord[1];
        }
    },

    /**
     * Auto-scroll the window if the dragged object has been moved beyond the 
     * visible window boundary.
     * @method autoScroll
     * @param {int} x the drag element's x position
     * @param {int} y the drag element's y position
     * @param {int} h the height of the drag element
     * @param {int} w the width of the drag element
     * @private
     */
    autoScroll: function(x, y, h, w) {

        if (this.scroll) {
            // The client height
            var clientH = this.DDM.getClientHeight();

            // The client width
            var clientW = this.DDM.getClientWidth();

            // The amt scrolled down
            var st = this.DDM.getScrollTop();

            // The amt scrolled right
            var sl = this.DDM.getScrollLeft();

            // Location of the bottom of the element
            var bot = h + y;

            // Location of the right of the element
            var right = w + x;

            // The distance from the cursor to the bottom of the visible area, 
            // adjusted so that we don't scroll if the cursor is beyond the
            // element drag constraints
            var toBot = (clientH + st - y - this.deltaY);

            // The distance from the cursor to the right of the visible area
            var toRight = (clientW + sl - x - this.deltaX);


            // How close to the edge the cursor must be before we scroll
            // var thresh = (document.all) ? 100 : 40;
            var thresh = 40;

            // How many pixels to scroll per autoscroll op.  This helps to reduce 
            // clunky scrolling. IE is more sensitive about this ... it needs this 
            // value to be higher.
            var scrAmt = (document.all) ? 80 : 30;

            // Scroll down if we are near the bottom of the visible page and the 
            // obj extends below the crease
            if ( bot > clientH && toBot < thresh ) { 
                window.scrollTo(sl, st + scrAmt); 
            }

            // Scroll up if the window is scrolled down and the top of the object
            // goes above the top border
            if ( y < st && st > 0 && y - st < thresh ) { 
                window.scrollTo(sl, st - scrAmt); 
            }

            // Scroll right if the obj is beyond the right border and the cursor is
            // near the border.
            if ( right > clientW && toRight < thresh ) { 
                window.scrollTo(sl + scrAmt, st); 
            }

            // Scroll left if the window has been scrolled to the right and the obj
            // extends past the left border
            if ( x < sl && sl > 0 && x - sl < thresh ) { 
                window.scrollTo(sl - scrAmt, st);
            }
        }
    },

    /*
     * Sets up config options specific to this class. Overrides
     * YAHOO.util.DragDrop, but all versions of this method through the 
     * inheritance chain are called
     */
    applyConfig: function() {
        YAHOO.util.DD.superclass.applyConfig.call(this);
        this.scroll = (this.config.scroll !== false);
    },

    /*
     * Event that fires prior to the onMouseDown event.  Overrides 
     * YAHOO.util.DragDrop.
     */
    b4MouseDown: function(e) {
        this.setStartPosition();
        // this.resetConstraints();
        this.autoOffset(YAHOO.util.Event.getPageX(e), 
                            YAHOO.util.Event.getPageY(e));
    },

    /*
     * Event that fires prior to the onDrag event.  Overrides 
     * YAHOO.util.DragDrop.
     */
    b4Drag: function(e) {
        this.setDragElPos(YAHOO.util.Event.getPageX(e), 
                            YAHOO.util.Event.getPageY(e));
    },

    toString: function() {
        return ("DD " + this.id);
    }

    //////////////////////////////////////////////////////////////////////////
    // Debugging ygDragDrop events that can be overridden
    //////////////////////////////////////////////////////////////////////////
    /*
    startDrag: function(x, y) {
    },

    onDrag: function(e) {
    },

    onDragEnter: function(e, id) {
    },

    onDragOver: function(e, id) {
    },

    onDragOut: function(e, id) {
    },

    onDragDrop: function(e, id) {
    },

    endDrag: function(e) {
    }

    */

/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent 
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
});
/**
 * A DragDrop implementation that inserts an empty, bordered div into
 * the document that follows the cursor during drag operations.  At the time of
 * the click, the frame div is resized to the dimensions of the linked html
 * element, and moved to the exact location of the linked element.
 *
 * References to the "frame" element refer to the single proxy element that
 * was created to be dragged in place of all DDProxy elements on the
 * page.
 *
 * @class DDProxy
 * @extends YAHOO.util.DD
 * @constructor
 * @param {String} id the id of the linked html element
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                Valid properties for DDProxy in addition to those in DragDrop: 
 *                   resizeFrame, centerFrame, dragElId
 */
YAHOO.util.DDProxy = function(id, sGroup, config) {
    if (id) {
        this.init(id, sGroup, config);
        this.initFrame(); 
    }
};

/**
 * The default drag frame div id
 * @property YAHOO.util.DDProxy.dragElId
 * @type String
 * @static
 */
YAHOO.util.DDProxy.dragElId = "ygddfdiv";

YAHOO.extend(YAHOO.util.DDProxy, YAHOO.util.DD, {

    /**
     * By default we resize the drag frame to be the same size as the element
     * we want to drag (this is to get the frame effect).  We can turn it off
     * if we want a different behavior.
     * @property resizeFrame
     * @type boolean
     */
    resizeFrame: true,

    /**
     * By default the frame is positioned exactly where the drag element is, so
     * we use the cursor offset provided by YAHOO.util.DD.  Another option that works only if
     * you do not have constraints on the obj is to have the drag frame centered
     * around the cursor.  Set centerFrame to true for this effect.
     * @property centerFrame
     * @type boolean
     */
    centerFrame: false,

    /**
     * Creates the proxy element if it does not yet exist
     * @method createFrame
     */
    createFrame: function() {
        var self=this, body=document.body;

        if (!body || !body.firstChild) {
            setTimeout( function() { self.createFrame(); }, 50 );
            return;
        }

        var div=this.getDragEl(), Dom=YAHOO.util.Dom;

        if (!div) {
            div    = document.createElement("div");
            div.id = this.dragElId;
            var s  = div.style;

            s.position   = "absolute";
            s.visibility = "hidden";
            s.cursor     = "move";
            s.border     = "2px solid #aaa";
            s.zIndex     = 999;
            s.height     = "25px";
            s.width      = "25px";

            var _data = document.createElement('div');
            Dom.setStyle(_data, 'height', '100%');
            Dom.setStyle(_data, 'width', '100%');
            /**
            * If the proxy element has no background-color, then it is considered to the "transparent" by Internet Explorer.
            * Since it is "transparent" then the events pass through it to the iframe below.
            * So creating a "fake" div inside the proxy element and giving it a background-color, then setting it to an
            * opacity of 0, it appears to not be there, however IE still thinks that it is so the events never pass through.
            */
            Dom.setStyle(_data, 'background-color', '#ccc');
            Dom.setStyle(_data, 'opacity', '0');
            div.appendChild(_data);

            // appendChild can blow up IE if invoked prior to the window load event
            // while rendering a table.  It is possible there are other scenarios 
            // that would cause this to happen as well.
            body.insertBefore(div, body.firstChild);
        }
    },

    /**
     * Initialization for the drag frame element.  Must be called in the
     * constructor of all subclasses
     * @method initFrame
     */
    initFrame: function() {
        this.createFrame();
    },

    applyConfig: function() {
        YAHOO.util.DDProxy.superclass.applyConfig.call(this);

        this.resizeFrame = (this.config.resizeFrame !== false);
        this.centerFrame = (this.config.centerFrame);
        this.setDragElId(this.config.dragElId || YAHOO.util.DDProxy.dragElId);
    },

    /**
     * Resizes the drag frame to the dimensions of the clicked object, positions 
     * it over the object, and finally displays it
     * @method showFrame
     * @param {int} iPageX X click position
     * @param {int} iPageY Y click position
     * @private
     */
    showFrame: function(iPageX, iPageY) {
        var el = this.getEl();
        var dragEl = this.getDragEl();
        var s = dragEl.style;

        this._resizeProxy();

        if (this.centerFrame) {
            this.setDelta( Math.round(parseInt(s.width,  10)/2), 
                           Math.round(parseInt(s.height, 10)/2) );
        }

        this.setDragElPos(iPageX, iPageY);

        YAHOO.util.Dom.setStyle(dragEl, "visibility", "visible"); 
    },

    /**
     * The proxy is automatically resized to the dimensions of the linked
     * element when a drag is initiated, unless resizeFrame is set to false
     * @method _resizeProxy
     * @private
     */
    _resizeProxy: function() {
        if (this.resizeFrame) {
            var DOM    = YAHOO.util.Dom;
            var el     = this.getEl();
            var dragEl = this.getDragEl();

            var bt = parseInt( DOM.getStyle(dragEl, "borderTopWidth"    ), 10);
            var br = parseInt( DOM.getStyle(dragEl, "borderRightWidth"  ), 10);
            var bb = parseInt( DOM.getStyle(dragEl, "borderBottomWidth" ), 10);
            var bl = parseInt( DOM.getStyle(dragEl, "borderLeftWidth"   ), 10);

            if (isNaN(bt)) { bt = 0; }
            if (isNaN(br)) { br = 0; }
            if (isNaN(bb)) { bb = 0; }
            if (isNaN(bl)) { bl = 0; }


            var newWidth  = Math.max(0, el.offsetWidth  - br - bl);                                                                                           
            var newHeight = Math.max(0, el.offsetHeight - bt - bb);


            DOM.setStyle( dragEl, "width",  newWidth  + "px" );
            DOM.setStyle( dragEl, "height", newHeight + "px" );
        }
    },

    // overrides YAHOO.util.DragDrop
    b4MouseDown: function(e) {
        this.setStartPosition();
        var x = YAHOO.util.Event.getPageX(e);
        var y = YAHOO.util.Event.getPageY(e);
        this.autoOffset(x, y);

        // This causes the autoscroll code to kick off, which means autoscroll can
        // happen prior to the check for a valid drag handle.
        // this.setDragElPos(x, y);
    },

    // overrides YAHOO.util.DragDrop
    b4StartDrag: function(x, y) {
        // show the drag frame
        this.showFrame(x, y);
    },

    // overrides YAHOO.util.DragDrop
    b4EndDrag: function(e) {
        YAHOO.util.Dom.setStyle(this.getDragEl(), "visibility", "hidden"); 
    },

    // overrides YAHOO.util.DragDrop
    // By default we try to move the element to the last location of the frame.  
    // This is so that the default behavior mirrors that of YAHOO.util.DD.  
    endDrag: function(e) {
        var DOM = YAHOO.util.Dom;
        var lel = this.getEl();
        var del = this.getDragEl();

        // Show the drag frame briefly so we can get its position
        // del.style.visibility = "";
        DOM.setStyle(del, "visibility", ""); 

        // Hide the linked element before the move to get around a Safari 
        // rendering bug.
        //lel.style.visibility = "hidden";
        DOM.setStyle(lel, "visibility", "hidden"); 
        YAHOO.util.DDM.moveToEl(lel, del);
        //del.style.visibility = "hidden";
        DOM.setStyle(del, "visibility", "hidden"); 
        //lel.style.visibility = "";
        DOM.setStyle(lel, "visibility", ""); 
    },

    toString: function() {
        return ("DDProxy " + this.id);
    }
/**
* @event mouseDownEvent
* @description Provides access to the mousedown event. The mousedown does not always result in a drag operation.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4MouseDownEvent
* @description Provides access to the mousedown event, before the mouseDownEvent gets fired. Returning false will cancel the drag.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event mouseUpEvent
* @description Fired from inside DragDropMgr when the drag operation is finished.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4StartDragEvent
* @description Fires before the startDragEvent, returning false will cancel the startDrag Event.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event startDragEvent
* @description Occurs after a mouse down and the drag threshold has been met. The drag threshold default is either 3 pixels of mouse movement or 1 full second of holding the mousedown. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event b4EndDragEvent
* @description Fires before the endDragEvent. Returning false will cancel.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event endDragEvent
* @description Fires on the mouseup event after a drag has been initiated (startDrag fired).
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

/**
* @event dragEvent
* @description Occurs every mousemove event while dragging.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragEvent
* @description Fires before the dragEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event invalidDropEvent
* @description Fires when the dragged objects is dropped in a location that contains no drop targets.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOutEvent
* @description Fires before the dragOutEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOutEvent
* @description Fires when a dragged object is no longer over an object that had the onDragEnter fire. 
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragEnterEvent
* @description Occurs when the dragged object first interacts with another targettable drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragOverEvent
* @description Fires before the dragOverEvent.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragOverEvent
* @description Fires every mousemove event while over a drag and drop object.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event b4DragDropEvent 
* @description Fires before the dragDropEvent
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/
/**
* @event dragDropEvent
* @description Fires when the dragged objects is dropped on another.
* @type YAHOO.util.CustomEvent See <a href="YAHOO.util.Element.html#addListener">Element.addListener</a> for more information on listening for this event.
*/

});
/**
 * A DragDrop implementation that does not move, but can be a drop 
 * target.  You would get the same result by simply omitting implementation 
 * for the event callbacks, but this way we reduce the processing cost of the 
 * event listener and the callbacks.
 * @class DDTarget
 * @extends YAHOO.util.DragDrop 
 * @constructor
 * @param {String} id the id of the element that is a drop target
 * @param {String} sGroup the group of related DragDrop objects
 * @param {object} config an object containing configurable attributes
 *                 Valid properties for DDTarget in addition to those in 
 *                 DragDrop: 
 *                    none
 */
YAHOO.util.DDTarget = function(id, sGroup, config) {
    if (id) {
        this.initTarget(id, sGroup, config);
    }
};

// YAHOO.util.DDTarget.prototype = new YAHOO.util.DragDrop();
YAHOO.extend(YAHOO.util.DDTarget, YAHOO.util.DragDrop, {
    toString: function() {
        return ("DDTarget " + this.id);
    }
});
YAHOO.register("dragdrop", YAHOO.util.DragDropMgr, {version: "2.8.1", build: "19"});


/* js/apps/ProfileConstants.js */

LI.define("Profile.Constants");
LI.Profile.Constants.NEW_ORDER_SAVE_KEY="newOrder";
LI.Profile.Constants.OLD_ORDER_SAVE_KEY="oldOrder";
LI.Profile.Constants.RESUME_CLASS="resume";
LI.Profile.Constants.SORTABLE_CLASS="sortable";
LI.Profile.Constants.SORTABLE_CLASS="draggable";
LI.Profile.Constants.IS_BEING_DRAGGED_CLASS="dragged";
LI.Profile.Constants.IS_BEING_SAVED_CLASS="saving";
LI.Profile.Constants.DRAG_PROXY_CLASS="dragProxy";
LI.Profile.Constants.DRAG_HANDLE_CLASS="drag-handle";
LI.Profile.Constants.DRAG_HANDLE_HOVER_CLASS="drag-handle-hover";
LI.Profile.Constants.COLLAPSABLE_CLASS="collapsable";
LI.Profile.Constants.IS_COLLAPSED_CLASS="collapsed";
LI.Profile.Constants.COLLAPSE_HANDLE_CLASS="collapse-handle";
LI.Profile.Constants.COLLAPSE_HANDLE_HOVER_CLASS="collapse-handle-hover";

/* js/apps/ProfileSortableSection.js */

LI.define("Profile.SortableSection");
(function(){var a=null;
LI.Profile.SortableSection.onCreatePostData=function(f,n,c){if(n&&c){var d=Y$("#"+c.orderInputId,n,true);
d.value=f.join(",");
return""
}else{if(!a){a=[];
var j=LI.Sortable.Region.getRegionById(Y$(".resume")[0].id);
var m=j.getSections();
for(var g=0,e=Y$(".resume .draggable"),h=e.length;
g<h;
g++){var b=e[g].id;
var l=m[b].getServerValue();
a.push(l)
}}var k=[LI.Profile.Constants.NEW_ORDER_SAVE_KEY+"="+escape(f.join(",")),LI.Profile.Constants.OLD_ORDER_SAVE_KEY+"="+escape(a.join(","))].join("&");
a=f;
return k
}}
})();

/* js/util/SortableSection.js */

LI.define("Sortable.Constants");
LI.Sortable.Constants={SORTABLE_REGION_CLASS:"sortable",SORTABLE_SECTION_CLASS:"draggable",IS_BEING_DRAGGED_CLASS:"dragged",IS_BEING_SAVED_CLASS:"saving",DRAG_PROXY_CLASS:"drag-proxy",DRAG_HANDLE_CLASS:"drag-handle",DRAG_HANDLE_HOVER_CLASS:"drag-handle-hover"};
LI.define("Sortable.Region");
LI.Sortable.Region=function(e,c){var b=this;
c={saveUrl:c.saveUrl||null,saveNode:c.saveNode||null,onRegister:c.onRegister||function(){},onInit:c.onInit||function(){},onCreatePostData:c.onCreatePostData||function(h){return"order="+escape(h.join(","))
},onSuccess:c.onSuccess||function(){},scope:c.scope||b,group:c.group||"ig-"+YDom.generateId(),helpText:c.helpText||null,useForm:c.useForm||false,createPostDataConfig:c.createPostDataConfig||null};
var g=LI.Sortable.createGroupIdentifier(c.group);
var a={};
if(!e.id){e.id=YDom.generateId()
}if(typeof(c.onRegister)=="string"){var d=LI.Controls.resolveName(c.onRegister);
if(d){c.onRegister=d
}else{throw new Error("onRegister could not be resolved")
}}if(typeof(c.onInit)=="string"){var d=LI.Controls.resolveName(c.onInit);
if(d){c.onInit=d
}else{throw new Error("onCreatePostData could not be resolved")
}}if(typeof(c.onCreatePostData)=="string"){var d=LI.Controls.resolveName(c.onCreatePostData);
if(d){c.onCreatePostData=d
}else{throw new Error("onCreatePostData could not be resolved")
}}if(typeof(c.onSuccess)=="string"){var d=LI.Controls.resolveName(c.onSuccess);
if(d){c.onSuccess=d
}else{throw new Error("onSuccess could not be resolved")
}}var f=function(q,k){YDom.addClass(q,LI.Sortable.Constants.IS_BEING_SAVED_CLASS);
var l=[];
for(var m=0,n=k.length;
m<n;
m++){l.push(a[k[m]].getServerValue())
}if(c.useForm){var o=Y$(c.useForm,e,true);
if(o){c.saveUrl=o.action;
var j=c.onCreatePostData.call(c.scope,l,o,c.createPostDataConfig);
YAHOO.util.Connect.setForm(o)
}}else{var j=c.onCreatePostData.call(c.scope,l)
}if(c.saveNode){var h=Y$(c.saveNode)[0];
if(h.tagName.toLowerCase()=="form"){c.saveUrl=h.action;
c.saveNode=null
}else{if(h.tagName.toLowerCase()=="a"){c.saveUrl=h.href;
c.saveNode=null
}else{throw new Error("config.saveNode "+c.saveNode+" not found.")
}}}var p=LI.asyncRequest("POST",c.saveUrl,{success:function(i){YDom.removeClass(q,LI.Sortable.Constants.IS_BEING_SAVED_CLASS);
c.onSuccess.call(c.scope,i)
},failure:function(i){},scope:b,argument:[],cache:false,custom:{error:function(){window.scrollTo(0,0)
}}},j)
};
this.registerSection=function(i){a[i.getEl().id]=i;
YDom.addClass(i.getEl(),g);
var h=i.getDDObject();
h.setSaveCallback(f);
c.onRegister.call(c.scope,i)
};
this.getHelpText=function(){return c.helpText
};
this.getSections=function(){return a
};
LI.Sortable.Region.setRegion(c.group,e.id,b);
window.setTimeout(function(){c.onInit.call(c.scope)
},1)
};
(function(){var b={};
var d={};
var a={};
var c=function(f,e){f.registerSection(e);
e.setRegion(f)
};
LI.Sortable.Region.getRegionByGroup=function(e){return b[e]
};
LI.Sortable.Region.getRegionById=function(e){return d[e]
};
LI.Sortable.Region.setRegion=function(h,j,g){b[h]=g;
d[j]=g;
if(a[h]&&a[h].length){for(var f=0,e=a[h].length;
f<e;
f++){c(g,a[h][f])
}a[h]=null
}};
LI.Sortable.Region.register=function(f){var g=f.getGroup();
var e=LI.Sortable.Region.getRegionByGroup(g);
if(e){c(e,f);
return
}if(!a[g]){a[g]=[]
}a[g].push(f)
};
LI.Sortable.createGroupIdentifier=function(e){return"li-ig-"+e
}
})();
LI.define("Sortable.Section");
LI.Sortable.Section=function(b,s){s={existingDragHandlePath:s.existingDragHandlePath||null,createDragHandlePath:s.createDragHandlePath||null,group:s.group||null,serverValue:s.serverValue||null};
var r=null,i=[];
if(!b.id){b.id=YDom.generateId()
}if(!s.serverValue){throw new Error("Each section must have a corresponding key for the server.")
}this.getEl=function(){return b
};
this.getServerValue=function(){return s.serverValue
};
this.getDDObject=function(){return r
};
this.getGroup=function(){return s.group
};
this.setRegion=function(v){var u=v.getHelpText();
if(u){for(var t=0,j=i.length;
t<j;
t++){i[t].title=u
}}};
var a=this;
YDom.addClass(b,LI.Sortable.Constants.SORTABLE_SECTION_CLASS);
r=new LI.Sortable.ddExt(b,s.group,{useShim:true});
var e="#"+b.id+" "+s.existingDragHandlePath;
var m="#"+b.id+" "+s.createDragHandlePath;
var d=function(j){try{j.style.visibility="hidden";
j.style.visibility=""
}catch(t){}};
var q=function(){var j=document.createElement("div");
j.id=YDom.generateId();
j=p(j);
return j
};
var p=function(j){YDom.addClass(j,LI.Sortable.Constants.DRAG_HANDLE_CLASS);
YEvent.on(j,"mouseover",function(t){YDom.addClass(j,LI.Sortable.Constants.DRAG_HANDLE_HOVER_CLASS)
});
YEvent.on(j,"mouseout",function(t){YDom.removeClass(j,LI.Sortable.Constants.DRAG_HANDLE_HOVER_CLASS)
});
i.push(j)
};
var n=document.createElement("div");
var c=document.createElement("span");
var l=document.createTextNode(" ");
YDom.addClass(n,"progress-indicator");
n.appendChild(c);
c.appendChild(l);
b.appendChild(n);
if(s.existingDragHandlePath){for(var k=0,h=Y$(e),f=h.length;
k<f;
k++){var o=h[k];
if(!o.id){o.id=YDom.generateId()
}p(o);
r.setHandleElId(o.id);
d(o)
}}if(s.createDragHandlePath){for(var k=0,h=Y$(m),f=h.length;
k<f;
k++){var g=h[k];
var o=q();
r.setHandleElId(o.id);
g.insertBefore(o,g.firstChild);
d(g)
}YDom.addClass(b,LI.Sortable.Constants.SORTABLE_CLASS)
}LI.Sortable.Region.register(a)
};
LI.define("Sortable.ddExt");
LI.Sortable.ddExt=function(c,a,b){LI.Sortable.ddExt.superclass.constructor.call(this,c,a,b);
this.groupName=a;
this.goingUp=false;
this.lastY=0;
this.saver=function(){}
};
YAHOO.lang.extend(LI.Sortable.ddExt,YAHOO.util.DDProxy,{setSaveCallback:function(a,b){this.saver={fn:a,scope:b||this}
},toString:function(){return"SortableDDProxy"
},startDrag:function(c,h){var b=this.getDragEl();
var g=this.getEl();
var d=YDom.getElementsByClassName("progress-indicator","div",g)[0];
if(d&&!d.style.height){d.style.height=g.offsetHeight+"px"
}d.style.display="block";
YDom.addClass(g,LI.Sortable.Constants.IS_BEING_DRAGGED_CLASS);
b.innerHTML=g.innerHTML.replace(/id="(.*?)"/,'id="$1_0"').replace(/<iframe.*?<\/iframe>/,"");
YDom.addClass(b,LI.Sortable.Constants.RESUME_CLASS);
YDom.addClass(b,LI.Sortable.Constants.SORTABLE_CLASS);
for(var f=0,e=YDom.get(g).className.split(" "),a=e.length;
f<a;
f++){if(e[f]==LI.Sortable.Constants.IS_BEING_DRAGGED_CLASS){continue
}YDom.addClass(b,e[f])
}YDom.addClass(b,LI.Sortable.Constants.DRAG_PROXY_CLASS);
YDom.removeClass(b,LI.Sortable.createGroupIdentifier(this.groupName));
YAHOO.util.DragDropMgr.refreshCache()
},endDrag:function(l){var c=this.getEl();
var m=this.getDragEl();
var d=m.id;
var g=this.id;
var f=YDom.getElementsByClassName("progress-indicator","div",c)[0];
var h=[];
for(var j=0,b=Y$("."+LI.Sortable.createGroupIdentifier(this.groupName)),k=b.length;
j<k;
j++){h.push(b[j].id)
}try{this.saver.fn.call(this.saver.scope,g,h)
}catch(l){}var n=new YAHOO.util.Motion(m,{points:{to:YDom.getXY(c)}},0.2,YAHOO.util.Easing.easeOut);
n.onTween.subscribe(function(){YDom.setStyle(d,"visibility","visible")
});
n.onComplete.subscribe(function(){YDom.removeClass(g,LI.Sortable.Constants.IS_BEING_DRAGGED_CLASS);
if(!c.id){c.id=YDom.generateId()
}for(var o=0,r=Y$("#"+c.id+" iframe"),a=r.length;
o<a;
o++){var q=null;
try{q=r[o].getAttribute("data-li-src");
if(q){r[o].src=q
}}catch(p){}}YDom.get(d).className="";
YDom.setStyle(d,"visibility","hidden");
YDom.get(d).innerHTML="";
if(f){f.style.display="none"
}try{domNode.style.visibility="hidden";
domNode.style.visibility=""
}catch(p){}});
n.animate()
},onDrag:function(a){var b=YEvent.getPageY(a);
if(b<this.lastY){this.goingUp=true
}else{if(b>this.lastY){this.goingUp=false
}}this.lastY=b
},onDragOver:function(c,d){var b=this.getEl();
var a=YDom.get(d);
if(this.goingUp){a.parentNode.insertBefore(b,a)
}else{a.parentNode.insertBefore(b,a.nextSibling)
}YAHOO.util.DragDropMgr.refreshCache()
}});

/* js/ajax/chameleon_service.js */

var ChameleonService={panels:{},deleteModuleErrorMessage:"Please delete a module before adding another.",loadApe:true,setPanel:function(b,a){ChameleonService.panels[b]=a
},init:function(){ChameleonService.onChamPanelComplete=new YAHOO.util.CustomEvent("Chameleon Panel Complete")
},grantPermission:function(b,a,d,c){ChameleonAjaxService.grantPermission(b,a,d,function(e){if(c){if(e&&e.hadError){c(e)
}if(e){c(["VIEWER"])
}}})
},getProfileUrlFor:function(a,b,c){ChameleonAjaxService.getProfileUrlFor(a,b,function(d){var f=new Array(d.length);
for(var e=0;
e<d.length;
e++){f[e]=LI.htmlUnencode(d[e])
}c(f)
})
},showError:function(a){LI.injectAlert(a,"error");
document.location.href="#header"
},submitForm:function(formName){var map=lui.ui.form2Map.convertByFormId(formName);
ChameleonAjaxService.submitForm(map,formName,function(result){if(!ChameleonService.checkError(result)){var unencodedJson=LI.htmlUnencode(result.javascriptResponse);
var appInfo=eval("("+unencodedJson+")");
var slot=appInfo.app;
ChameleonService.reIDSlotDiv(appInfo.oldDivID,slot.divID);
ChameleonService.replaceSlot(slot.divID,slot.content);
if(result.slotDivID!=null&&result.slotDivID.length>0){setupModules.initSlot(result.slotDivID,false)
}}})
},savePrefs:function(c,b,d,f){if(ChameleonService.saveAppPreferencesURL){var e=[];
if(c){for(pref in c){e.push(pref+":"+c[pref])
}e=e.join("|")
}var a="&panelID="+escape(d)+"&appID="+escape(f)+"&pageID="+escape(b)+"&prefMap="+escape(e);
LI.asyncRequest("POST",ChameleonService.saveAppPreferencesURL,{failure:function(){},success:function(){}},a)
}else{ChameleonAjaxService.savePrefs(b,d,f,c,function(g){})
}},deleteOSApplication:function(b,c,d){if(ChameleonService.deleteOSAppURL){var a="&panelID="+escape(c)+"&appID="+escape(d);
LI.asyncRequest("POST",ChameleonService.deleteOSAppURL,{failure:function(){},success:function(e){var f=YAHOO.lang.JSON.parse(e.responseText);
if(f){if(f.errorCode){ChameleonService.showError(ChameleonService.deleteModuleErrorMessage)
}var g=f.txId;
ChameleonService.panels[c].txId=g
}}},a)
}else{ChameleonAjaxService.deleteOSApplication(c,d,ChameleonService.handleOsAppDeteleEvalResponse)
}},loadPanel:function(pageID,panelID,titleTag){ChameleonAjaxService.loadPanel(pageID,panelID,titleTag,function(result){if(!ChameleonService.checkError(result)){var unencodedJson=LI.htmlUnencode(result.javascriptResponse);
var panel=eval("("+unencodedJson+")");
var panelDiv=YDom.get(panel.panelDiv);
ChameleonService.setPanel(panelID,{div:panelDiv,txId:panel.txId,maxSlots:panel.maxSlots});
var slots=panel.panel;
var hasGadgets=false;
var gadgetTitleDivs=new Array();
var j=0;
for(var i=0;
i<slots.length;
i++){var slot=slots[i];
if(!slot.appType){ChameleonService.createSlot(panelDiv,slot.divID,"","h4")
}else{switch(slot.appType){case 1:ChameleonService.createSlot(panelDiv,slot.divID,"","h4");
ChameleonService.replaceSlot(slot.divID,slot.content);
ChameleonService.trackLinks(slot.pageID,slot.panelID,slot.appID,slot.divID);
ChameleonService.initSlot(slot.divID);
break;
case 3:ChameleonService.createSlot(panelDiv,slot.divID,"","h4");
if(slot.apeUrl){ChameleonService.getApeContent(slot.apeUrl,slot.pageSlot,slot.divID,slot.isExpanded);
ChameleonService.initSlot(slot.divID)
}break;
case 4:ChameleonService.createSlot(panelDiv,slot.divID,"","h4");
ChameleonService.loadGadget(slot.divID,slot,true);
hasGadgets=true;
gadgetTitleDivs[j]={"divId":"panel-0"+slot.panelID+"-slot-"+slot.appID+"-remote-title","title":slot.title};
j++;
break
}}}if(hasGadgets){gadgets.container.renderGadgets();
YDom.addClass("profile-applications","installed-apps");
for(var i=0;
i<gadgetTitleDivs.length;
i++){YDom.get(gadgetTitleDivs[i]["divId"]).innerHTML=gadgetTitleDivs[i]["title"]
}}}})
},loadChamSlotsOnPanel:function(pageID,panelID,titleTag,installationExpandedMap,txId,panelDivId,maxSlots){ChameleonService.setPanel(panelID,{div:document.getElementById(panelDivId),txId:txId,maxSlots:maxSlots});
if(installationExpandedMap){ChameleonAjaxService.loadApplicationsFor(pageID,panelID,titleTag,installationExpandedMap,txId,function(result){if(!ChameleonService.checkError(result)){var unencodedJson=LI.htmlUnencode(result.javascriptResponse);
var panel=eval("("+unencodedJson+")");
var panelDiv=document.getElementById(panel.panelDiv);
var slots=panel.panel;
var j=0;
for(var i=0;
i<slots.length;
i++){var slot=slots[i];
if(!slot.appType){ChameleonService.createSlot(panelDiv,slot.divID,"","h4")
}else{switch(slot.appType){case 1:ChameleonService.replaceSlot(slot.divID,slot.content);
ChameleonService.trackLinks(slot.pageID,slot.panelID,slot.appID,slot.divID);
ChameleonService.initSlot(slot.divID);
break;
case 3:if(slot.apeUrl){ChameleonService.getApeContent(slot.apeUrl,slot.pageSlot,slot.divID,slot.isExpanded);
ChameleonService.initSlot(slot.divID)
}break
}}}}})
}},loadChamSlotsOnPanelV2:function(pageID,panelID,titleTag,installationExpandedMap,txId,panelDivId,maxSlots){if(installationExpandedMap){ChameleonAjaxService.loadApplicationsFor(pageID,panelID,titleTag,installationExpandedMap,txId,function(result){if(!ChameleonService.checkError(result)){var unencodedJson=LI.htmlUnencode(result.javascriptResponse);
var panel=eval("("+unencodedJson+")");
YAHOO.util.Event.onDOMReady(function(){ChameleonService.setPanel(panelID,{div:document.getElementById(panelDivId),txId:txId,maxSlots:maxSlots});
var panelDiv=document.getElementById(panel.panelDiv);
var slots=panel.panel;
var j=0;
for(var i=0;
i<slots.length;
i++){var slot=slots[i];
if(!slot.appType){ChameleonService.createSlot(panelDiv,slot.divID,"","h4")
}else{switch(slot.appType){case 1:ChameleonService.replaceSlot(slot.divID,slot.content);
ChameleonService.trackLinks(slot.pageID,slot.panelID,slot.appID,slot.divID);
ChameleonService.initSlot(slot.divID);
break;
case 3:if(slot.apeUrl){ChameleonService.getApeContent(slot.apeUrl,slot.pageSlot,slot.divID,slot.isExpanded);
ChameleonService.initSlot(slot.divID)
}break
}}}ChameleonService.onChamPanelComplete.fire(panel)
},panel)
}})
}},loadProfilePanel:function(ownerID,ownerHash){ChameleonAjaxService.loadProfilePanel(ownerID,ownerHash,function(result){if(!ChameleonService.checkError(result)){var unencodedJson=LI.htmlUnencode(result.javascriptResponse);
var panel=eval("("+unencodedJson+")");
var panelDiv=YDom.get(panel.panelDiv);
ChameleonService.panels[3]={div:panelDiv,txId:panel.txId};
var slots=panel.panel;
var hasGadgets=false;
for(var i=0;
i<slots.length;
i++){var slot=slots[i];
if(!slot.appType){ChameleonService.createSlot(panelDiv,slot.divID,"","h4")
}else{switch(slot.appType){case 1:ChameleonService.createSlot(panelDiv,slot.divID,"","h4");
ChameleonService.replaceSlot(slot.divID,slot.content);
ChameleonService.trackLinks(slot.pageID,slot.panelID,slot.appID,slot.divID);
ChameleonService.initSlot(slot.divID);
break;
case 3:ChameleonService.createSlot(panelDiv,slot.divID,"","h4");
if(slot.apeUrl){ChameleonService.getApeContent(slot.apeUrl,slot.pageSlot,slot.divID,slot.isExpanded);
ChameleonService.initSlot(slot.divID)
}break;
case 4:ChameleonService.createSlot(panelDiv,slot.divID,"","h4",true);
ChameleonService.loadGadget(slot.divID,slot,false);
hasGadgets=true;
break
}}}if(hasGadgets){gadgets.container.renderGadgets();
if(slots.length>0){YDom.addClass("profile-applications","installed-apps")
}}}})
},loadGenericProfilePanel:function(ownerID,ownerHash,panelId){ChameleonAjaxService.loadGenericProfilePanel(ownerID,ownerHash,panelId,function(result){if(!ChameleonService.checkError(result)){var unencodedJson=LI.htmlUnencode(result.javascriptResponse);
var panel=eval("("+unencodedJson+")");
var panelDiv=document.getElementById(panel.panelDiv);
ChameleonService.panels[3]={div:panelDiv,txId:panel.txId};
var slots=panel.panel;
var hasGadgets=false;
for(var i=0;
i<slots.length;
i++){var slot=slots[i];
if(!slot.appType){ChameleonService.createSlot(panelDiv,slot.divID,"","h4")
}else{switch(slot.appType){case 1:ChameleonService.createSlot(panelDiv,slot.divID,"","h4");
ChameleonService.replaceSlot(slot.divID,slot.content);
ChameleonService.trackLinks(slot.pageID,slot.panelID,slot.appID,slot.divID);
ChameleonService.initSlot(slot.divID);
break;
case 3:ChameleonService.createSlot(panelDiv,slot.divID,"","h4");
if(slot.apeUrl){ChameleonService.getApeContent(slot.apeUrl,slot.pageSlot,slot.divID,slot.isExpanded);
ChameleonService.initSlot(slot.divID)
}break;
case 4:ChameleonService.createSlot(panelDiv,slot.divID,"","h4",true);
ChameleonService.loadGadget(slot.divID,slot,false);
hasGadgets=true;
break
}}}if(hasGadgets){gadgets.container.renderGadgets();
if(slots.length>0){YAHOO.util.Dom.addClass(document.getElementById("profile-applications"),"installed-apps")
}}}})
},loadCanvas:function(pageID,panelID,applicationID,ownerID,canvasUrl,osSignature,completeSignature){ChameleonAjaxService.loadCanvas(pageID,panelID,applicationID,ownerID,canvasUrl,osSignature,completeSignature,function(result){if(!ChameleonService.checkError(result)){var unencodedJson=LI.htmlUnencode(result.javascriptResponse);
var appInfo=eval("("+unencodedJson+")");
if(appInfo.app&&appInfo.app.divID!=null){ChameleonService.loadGadget("opensocial-app-container-in-canvas",appInfo.app,false);
YDom.get("opensocial-gadget-title").innerHTML=appInfo.title;
document.title="LinkedIn: "+appInfo.title;
gadgets.container.renderGadgets()
}}})
},loadGadget:function(e,d,c){ChameleonService.replaceSlot(e,d.content);
gadgets.container.addGadgetChrome(d.appID,d.gadgetChromeID);
var f=gadgets.container.createGadget({specUrl:d.specUrl,secureToken:d.secureToken,id:d.appID});
f.setServerBase(d.serverBase);
f.setGadgetInfo(d.pageID,d.panelID,d.appID,d.urlToCanvasView,d.signedUrlToCanvasView,d.baseLeoNonSecureURL,d.ownerProfileUrl,d.viewerId,d.ownerId,d.applicationId,d.viewerAccess,d.isViewerTheOwner,d.language,d.country);
for(var b in d.prefs){var a=d.prefs[b];
f.userPrefs_[b]=a
}gadgets.container.addGadget(f);
if(c){ChameleonService.initSlot(d.divID,true)
}return f
},createInappGadget:function(c,h,d,i){gadgets.container.addGadgetChrome(h.appID,h.gadgetChromeID);
var b=gadgets.container.createGadget({specUrl:h.specUrl,secureToken:h.secureToken,id:h.appID});
b.setServerBase(h.serverBase);
b.setGadgetInfo(h.pageID,h.panelID,h.appID,h.urlToCanvasView,h.signedUrlToCanvasView,h.baseLeoNonSecureURL,h.ownerProfileUrl,h.viewerId,h.ownerId,h.applicationId,h.viewerAccess,h.isViewerTheOwner,h.language,h.country);
for(var a in h.prefs){var f=h.prefs[a];
b.userPrefs_[a]=f
}gadgets.container.addGadget(b);
if(d){ChameleonService.initSlot(h.divID,true)
}var e=b.getIframeId();
var g=b.rpcRelay;
gadgets.rpc.setRelayUrl(e,h.serverBase+g);
gadgets.rpc.setAuthToken(e,i);
return b
},loadInappGadget:function(panelDiv,jresponse,initializeDnD,rpcToken,panelID){var unencodedJson=LI.htmlUnencode(jresponse);
try{var appInfo=eval("("+unencodedJson+")")
}catch(err){}if(appInfo){ChameleonService.setPanel(panelID,{div:panelDiv,txId:appInfo.txId,maxSlots:appInfo.maxSlots});
if(appInfo.app&&appInfo.app.divID!=null){ChameleonService.createInappGadget(panelDiv,appInfo.app,initializeDnD,rpcToken)
}}},loadInappGadgetOnPanel:function(panelDiv,jresponse,initializeDnD){var unencodedJson=LI.htmlUnencode(jresponse);
var appInfo=eval("("+unencodedJson+")");
var content='<div class="module gadget open" id="'+appInfo.app.gadgetChromeID+'"></div>';
appInfo.app.content=content;
if(appInfo.app&&appInfo.app.divID!=null){var gadget=ChameleonService.loadGadget(panelDiv,appInfo.app,initializeDnD);
var chromeId=appInfo.app.gadgetChromeID;
var chrome=chromeId?document.getElementById(chromeId):null;
gadget.render(chrome);
var appTitleDivId="panel-0"+appInfo.app.panelID+"-slot-"+appInfo.app.appID+"-remote-title";
document.getElementById(appTitleDivId).innerHTML=appInfo.title
}},addNonOSApplicationOnNhome:function(f,g,d,b){var i=ChameleonService.getPanelOrder(g);
if(i){var c=i.slots;
var e=i.collapse;
if(c.length>=ChameleonService.panels[g].maxSlots){ChameleonService.showError(ChameleonService.deleteModuleErrorMessage);
return
}if(ChameleonService.addApplicationURL){if(c){c=c.join("|")
}var h=[];
if(e){for(panel in e){h.push(panel+":"+e[panel])
}h=h.join("|")
}var a="&panelID="+escape(g)+"&appID="+escape(d)+"&panelOrder="+escape(c)+"&collapsed="+escape(h)+"&titleTag="+escape(b)+"&txID="+escape(ChameleonService.panels[g].txId);
LI.asyncRequest("POST",ChameleonService.addApplicationURL,{failure:function(){},success:function(){}},a)
}}},addApplication:function(pageID,panelID,appID,titleTag,callback){var panelConfig=ChameleonService.getPanelOrder(panelID);
if(panelConfig){var slots=panelConfig.slots;
var collapsed=panelConfig.collapse;
if(slots.length>=ChameleonService.panels[panelID].maxSlots){ChameleonService.showError(ChameleonService.deleteModuleErrorMessage);
return
}ChameleonAjaxService.addApplication(panelID,appID,slots,collapsed,titleTag,ChameleonService.panels[panelID].txId,function(result){if(!ChameleonService.checkError(result)){var unencodedJson=LI.htmlUnencode(result.javascriptResponse);
var appInfo=eval("("+unencodedJson+")");
if(appInfo.app&&appInfo.app.divID!=null){var panelDiv=YDom.get(appInfo.panelDiv);
ChameleonService.panels[panelID].txId=appInfo.txId;
var e=ChameleonService.createSlot(panelDiv,appInfo.app.divID,appInfo.title,"h4");
ChameleonService.replaceSlot(appInfo.app.divID,appInfo.app.content);
setupModules.initSlot(appInfo.app.divID,true);
if(callback){callback()
}var module=YDom.getFirstChild(e);
if(!YDom.hasClass(module,"add")){YDom.addClass(module,"add")
}YEvent.preventDefault(e)
}}})
}},addGadget:function(a,b,d,e){var c=ChameleonService.getPanelOrder(b);
if(c){if(c.slots.length>=ChameleonService.panels[b].maxSlots){ChameleonService.showError(ChameleonService.deleteModuleErrorMessage);
return
}document.location.href=ChameleonService.leoNonSecureUrl+"opensocialInstallation/preview?_ch_panel_id="+b+"&_applicationId="+d
}},deleteApplication:function(a,b,c){ChameleonAjaxService.deleteApplication(b,c,ChameleonService.handleEvalResponse)
},collapseApplication:function(a,b,c){ChameleonService.savePanel(b)
},expandApplication:function(a,b,c){ChameleonService.savePanel(b)
},moveApplication:function(a,b,c,d){ChameleonService.savePanel(b)
},savePanel:function(panelID){var panelConfig=ChameleonService.getPanelOrder(panelID);
if(panelConfig){ChameleonAjaxService.savePanelOrder(panelID,panelConfig.slots,panelConfig.collapse,ChameleonService.panels[panelID].txId,function(result){if(!ChameleonService.checkError(result)){var unencodedJson=LI.htmlUnencode(result.javascriptResponse);
var appInfo=eval("("+unencodedJson+")");
if(appInfo.txId){ChameleonService.panels[panelID].txId=appInfo.txId
}}})
}},getPanelOrder:function(c){if(!ChameleonService.panels[c]){return null
}var g=ChameleonService.panels[c].div;
if(g){var f=g.childNodes;
var b=[];
var a={};
var e=0;
for(var d=0;
d<f.length;
d++){if(f[d].nodeName=="DIV"){b[e]=ChameleonService.getAppInstanceID(f[d].id);
a[b[e]]=ChameleonService.isSlotOpen(f[d]);
e++
}}var h={slots:b,collapse:a};
return h
}return null
},isSlotOpen:function(d){var c=d.childNodes;
if(c&&c.length>0){var a=c[0];
for(var b=0;
b<c.length;
b++){a=c[b];
if(a.nodeType==1){break
}}if(a.nodeType!=1){return true
}return YAHOO.util.Dom.hasClass(a,"open")
}return true
},getPanelID:function(a){var b=a.split("-");
if(b.length>=4){return b[1]
}return""
},getAppInstanceID:function(a){var b=a.split("-");
if(b.length>=4){return b[3]
}return""
},reIDSlotDiv:function(b,a){var c=YDom.get(b);
c.setAttribute("id",a)
},createApeSlot:function(e,c,a){var d=YDom.get(e);
var b=document.createElement("div");
b.setAttribute("id",c);
if(a){b.setAttribute("class","module ape open")
}else{b.setAttribute("class","module ape")
}d.appendChild(b)
},createSlot:function(b,g,f,d,a){var c=document.createElement("div");
c.setAttribute("id",g);
c.setAttribute("class","slot");
if(gadgets.setGadgetDefaultHeightToZero&&a){c.style.position="absolute";
c.style.left="-12345px"
}b.appendChild(c);
if(f!=""){var e=document.createElement(d);
e.innerHTML=f;
c.appendChild(e)
}return c
},trackLinkClick:function(e){ChameleonAjaxService.trackClick(this.pageID,this.panelID,this.appInstanceID,this.href,function(result){var unencodedJson=LI.htmlUnencode(result.javascriptResponse);
var resultObj=eval("("+unencodedJson+")");
if(resultObj.url){ChameleonService.redirect(resultObject.url)
}})
},checkError:function(a){switch(a.errorCode){case 100:ChameleonService.showError(ChameleonService.deleteModuleErrorMessage);
return true;
break;
case 200:return true;
break;
case -1:return false;
break;
default:return false
}},handleEvalResponse:function(result){switch(result.errorCode){case 100:ChameleonService.showError(ChameleonService.deleteModuleErrorMessage);
break;
case 200:case -1:break;
default:}var panelID=result.panelID;
var responseContent=result.javascriptResponse;
eval(responseContent)
},handleOsAppDeteleEvalResponse:function(result){switch(result.errorCode){case 100:ChameleonService.showError(ChameleonService.deleteModuleErrorMessage);
break;
case 200:case -1:break;
default:}var panelID=result.panelID;
var unencodedJson=LI.htmlUnencode(result.javascriptResponse);
var txInfo=eval("("+unencodedJson+")");
ChameleonService.panels[panelID].txId=txInfo.txId
},trackLinks:function(g,h,k,b){var m=YDom.get(b);
var n=YDom.getElementsByClassName("content","div",m);
for(var d=0;
d<n.length;
d++){var c=n[d];
var p=c.getElementsByTagName("a");
for(var e=0;
e<p.length;
e++){var l=p[e];
var a=l.getAttribute("href");
var f=YDom.hasClass(l,"no-track");
if(a!=null&&!f){var o=new Object();
o.pageID=g;
o.panelID=h;
o.appInstanceID=k;
o.href=a;
YEvent.on(l,"click",ChameleonService.trackLinkClick,o,true)
}}}},redirect:function(a){window.location=LI.htmlUnencode(a)
},clearPanel:function(b){var a=YDom.get(b);
a.innerHTML=""
},replaceSlot:function(a,b){var c=YDom.get(a);
c.innerHTML=b;
if(b==""||b==null){YDom.addClass(c,"empty")
}},initSlot:function(a,b){setupModules.initSlot(a,false,b)
},getApeContent:function(a,g,f,b){if(!ChameleonService.loadApe){return
}var c=false;
if(window.XMLHttpRequest){try{c=new XMLHttpRequest()
}catch(d){c=false
}}else{if(window.ActiveXObject){try{c=new ActiveXObject("Msxml2.XMLHTTP")
}catch(d){try{c=new ActiveXObject("Microsoft.XMLHTTP")
}catch(d){c=false
}}}}if(c){try{c.open("GET",a,true);
c.onreadystatechange=function(){if(c.readyState==4){if(c.status==200){var m=YDom.get(f);
m.innerHTML=c.responseText;
if(c.responseText.length>0){if(b){var k=YDom.getElementsByClassName("module","div",m);
for(var e=0;
e<k.length;
e++){YDom.addClass(k[e],"open")
}}var l=YDom.getElementsByClassName("header","div",m);
for(var h=0;
h<l.length;
h++){l[h].setAttribute("id",f+"-header")
}setupModules.initSlot(f,false)
}else{YDom.addClass(m,"empty")
}}else{}}};
c.send("")
}catch(d){}}}};
var setupModules=function(){var u;
var p;
var k=function(y){var x=YDom.getFirstChild(this);
if(!YDom.hasClass(x,"edit")){YDom.addClass(x,"edit")
}else{YDom.removeClass(x,"edit")
}YEvent.preventDefault(y)
};
var h=function(){for(var y=0;
y<u.length;
y++){var z=YDom.getElementsByClassName("edit","li",u[y]);
if(z!=null&&z.length>0){var x=z[0];
YEvent.on(x,"click",k,u[y],true)
}}};
var j=function(){for(var z=0;
z<u.length;
z++){var x=YDom.getElementsByClassName("cancel","a",u[z]);
if(x!=null&&x.length>0){var y=x[0];
var A=YEvent.getListeners(y,"click");
if(A==null||A.size==0){YEvent.on(y,"click",k,u[z],true)
}}}};
var f=function(){for(var z=0;
z<u.length;
z++){var x=YDom.getElementsByClassName("cancel","a",u[z]);
if(x!=null&&x.length>0){var y=x[0];
var A=YEvent.getListeners(y,"click");
if(A==null||A.size==0){YEvent.on(y,"click",w,u[z],true)
}}}};
var b=function(x){YDom.addClass(this.parentNode,"processing")
};
var d=function(){for(var x=0;
x<u.length;
x++){var z=YDom.getElementsByAttribute("type","submit","input",u[x]);
if(z!=null&&z.length>0){var A=z[0];
var y=YEvent.getListeners(A,"click");
if(y==null||y.size==0){YEvent.on(A,"click",b,u[x])
}}}};
var w=function(z){var y=new YAHOO.util.Anim(this,{opacity:{to:0}},0.3);
var x=this;
y.onComplete.subscribe(function(){x.parentNode.removeChild(x);
ChameleonService.deleteApplication(1,p,ChameleonService.getAppInstanceID(x.id))
});
y.animate();
YEvent.preventDefault(z)
};
var o=function(z){var y=new YAHOO.util.Anim(this,{opacity:{to:0}},0.3);
var x=this;
y.onComplete.subscribe(function(){x.parentNode.removeChild(x);
ChameleonService.deleteOSApplication(1,p,ChameleonService.getAppInstanceID(x.id))
});
y.animate();
YEvent.preventDefault(z)
};
var r=function(B){for(var x=0;
x<u.length;
x++){var A=YDom.getElementsByClassName("close","li",u[x]);
if(A!=null&&A.length>0){var z=A[0];
var y=YEvent.getListeners(z,"click");
if(y==null||y.size==0){if((B!=undefined)&&B){YEvent.on(z,"click",o,u[x],true)
}else{YEvent.on(z,"click",w,u[x],true)
}}}else{A=YDom.getElementsByClassName("close","div",u[x]);
if(A!=null&&A.length>0){var z=A[0];
var y=YEvent.getListeners(z,"click");
if(y==null||y.size==0){if((B!=undefined)&&B){YEvent.on(z,"click",o,u[x],true)
}else{YEvent.on(z,"click",w,u[x],true)
}}}else{A=YDom.getElementsByClassName("close","a",u[x]);
if(A!=null&&A.length>0){var z=A[0];
var y=YEvent.getListeners(z,"click");
if(y==null||y.size==0){if((B!=undefined)&&B){YEvent.on(z,"click",o,u[x],true)
}else{YEvent.on(z,"click",w,u[x],true)
}}}}}}};
var v=function(y){var x=YDom.getFirstChild(this);
if(!YDom.hasClass(x,"open")){YDom.addClass(x,"open");
ChameleonService.expandApplication(1,1,ChameleonService.getAppInstanceID(this.id))
}else{YDom.removeClass(x,"open");
ChameleonService.collapseApplication(1,1,ChameleonService.getAppInstanceID(this.id))
}YEvent.preventDefault(y)
};
var c=function(){for(var x=0;
x<u.length;
x++){var z=u[x].getElementsByTagName("h4");
if(z!=null&&z.length>0){var A=z[0];
var y=YEvent.getListeners(A,"click");
if(y==null||y.size==0){YEvent.on(A,"click",v,u[x],true)
}}}};
var n=function(){var z=u;
for(var y=0;
y<z.length;
y++){var x=new DDList(z[y].id);
x.setHandleElId(z[y].id+"-header")
}};
var m="h4";
var a=function(x){ChameleonService.addApplication(1,1,1,m);
YEvent.preventDefault(x)
};
var t=function(x){ChameleonService.addNonOSApplicationOnNhome(1,1,11,m);
YEvent.preventDefault(x)
};
var e=function(A){var x=YEvent.getTarget(A);
if(x&&x.id){var z=x.id.split("_");
var y=z[1];
ChameleonService.addNonOSApplicationOnNhome(1,1,y,m)
}YEvent.preventDefault(A)
};
var i=function(x){ChameleonService.addApplication(1,1,3,m);
YEvent.preventDefault(x)
};
var l=function(x){ChameleonService.addGadget(1,1,400,m);
YEvent.preventDefault(x)
};
var g=function(y,x){ChameleonService.addGadget(1,x.panel,x.app,m);
YEvent.preventDefault(y)
};
var s=function(y,x){ChameleonService.addGadget(1,3,500,m);
YEvent.preventDefault(y)
};
var q=function(x){YEvent.on("add-people-module","click",a);
YEvent.on("add-answers-module","click",i);
YEvent.on("add-referralcenter-module","click",t);
var z=YDom.getElementsByClassName("add-direct-module");
for(var y=0;
y<z.length;
y++){YEvent.on(z[y],"click",e)
}};
return{initSlot:function(y,A,B){var z=YDom.get(y);
var x=YDom.getAncestorByClassName(z,"customizable");
if(x!=null){u=[z];
r(B);
h();
if(A){f();
d()
}else{j();
d()
}c();
n()
}else{var x=YDom.getAncestorByClassName(z,"applications");
if(x!=null){u=[z];
r(B);
h();
if(A){f()
}else{j()
}c()
}}},addGadgetToPanel:function(y,x){ChameleonService.addGadget(1,x.panel,x.app,"h4");
YEvent.preventDefault(y)
},init:function(x,y){if(y){m=y
}p=x;
q(x);
setupModules.addOSHandler(x)
}}
}();

/* js/opensocial/rpc.js */

var gadgets=gadgets||{};
gadgets.config=function(){var a=[];
return{register:function(d,c,b){var e=a[d];
if(!e){e=[];
a[d]=e
}e.push({validators:c||{},callback:b})
},get:function(b){if(b){return configuration[b]||{}
}return configuration
},init:function(d,m){configuration=d;
for(var b in a){if(a.hasOwnProperty(b)){var c=a[b],h=d[b];
for(var g=0,f=c.length;
g<f;
++g){var k=c[g];
if(h&&!m){var e=k.validators;
for(var l in e){if(e.hasOwnProperty(l)){if(!e[l](h[l])){throw new Error('Invalid config value "'+h[l]+'" for parameter "'+l+'" in component "'+b+'"')
}}}}if(k.callback){k.callback(d)
}}}}},EnumValidator:function(e){var d=[];
if(arguments.length>1){for(var c=0,b;
(b=arguments[c]);
++c){d.push(b)
}}else{d=e
}return function(g){for(var f=0,h;
(h=d[f]);
++f){if(g===d[f]){return true
}}}
},RegExValidator:function(b){return function(c){return b.test(c)
}
},ExistsValidator:function(b){return typeof b!=="undefined"
},NonEmptyStringValidator:function(b){return typeof b==="string"&&b.length>0
},BooleanValidator:function(b){return typeof b==="boolean"
},LikeValidator:function(b){return function(d){for(var e in b){if(b.hasOwnProperty(e)){var c=b[e];
if(!c(d[e])){return false
}}}return true
}
}}
}();
var gadgets=gadgets||{};
gadgets.log=function(a){gadgets.log.logAtLevel(gadgets.log.INFO,a)
};
gadgets.warn=function(a){gadgets.log.logAtLevel(gadgets.log.WARNING,a)
};
gadgets.error=function(a){gadgets.log.logAtLevel(gadgets.log.ERROR,a)
};
gadgets.setLogLevel=function(a){gadgets.log.logLevelThreshold_=a
};
gadgets.log.logAtLevel=function(d,c){if(d<gadgets.log.logLevelThreshold_||!gadgets.log._console){return
}var b;
var a=gadgets.log._console;
if(d==gadgets.log.WARNING&&a.warn){a.warn(c)
}else{if(d==gadgets.log.ERROR&&a.error){a.error(c)
}else{if(a.log){a.log(c)
}}}};
gadgets.log.INFO=1;
gadgets.log.WARNING=2;
gadgets.log.NONE=4;
gadgets.log.logLevelThreshold_=gadgets.log.INFO;
gadgets.log._console=window.console?window.console:window.opera?window.opera.postError:undefined;
var tamings___=tamings___||[];
tamings___.push(function(a){___.grantRead(gadgets.log,"INFO");
___.grantRead(gadgets.log,"WARNING");
___.grantRead(gadgets.log,"ERROR");
___.grantRead(gadgets.log,"NONE");
caja___.whitelistFuncs([[gadgets,"log"],[gadgets,"warn"],[gadgets,"error"],[gadgets,"setLogLevel"],[gadgets.log,"logAtLevel"],])
});
var gadgets=gadgets||{};
if(window.JSON&&window.JSON.parse&&window.JSON.stringify){gadgets.json={parse:function(b){try{return window.JSON.parse(b)
}catch(a){return false
}},stringify:function(b){try{return window.JSON.stringify(b)
}catch(a){return null
}}}
}else{gadgets.json=function(){function f(n){return n<10?"0"+n:n
}Date.prototype.toJSON=function(){return[this.getUTCFullYear(),"-",f(this.getUTCMonth()+1),"-",f(this.getUTCDate()),"T",f(this.getUTCHours()),":",f(this.getUTCMinutes()),":",f(this.getUTCSeconds()),"Z"].join("")
};
var m={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"};
function stringify(value){var a,i,k,l,r=/["\\\x00-\x1f\x7f-\x9f]/g,v;
switch(typeof value){case"string":return r.test(value)?'"'+value.replace(r,function(a){var c=m[a];
if(c){return c
}c=a.charCodeAt();
return"\\u00"+Math.floor(c/16).toString(16)+(c%16).toString(16)
})+'"':'"'+value+'"';
case"number":return isFinite(value)?String(value):"null";
case"boolean":case"null":return String(value);
case"object":if(!value){return"null"
}a=[];
if(typeof value.length==="number"&&!value.propertyIsEnumerable("length")){l=value.length;
for(i=0;
i<l;
i+=1){a.push(stringify(value[i])||"null")
}return"["+a.join(",")+"]"
}for(k in value){if(k.match("___$")){continue
}if(value.hasOwnProperty(k)){if(typeof k==="string"){v=stringify(value[k]);
if(v){a.push(stringify(k)+":"+v)
}}}}return"{"+a.join(",")+"}"
}}return{stringify:stringify,parse:function(text){if(/^[\],:{}\s]*$/.test(text.replace(/\\["\\\/b-u]/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){return eval("("+text+")")
}return false
}}
}()
}var tamings___=tamings___||[];
tamings___.push(function(a){caja___.whitelistFuncs([[gadgets.json,"parse"],[gadgets.json,"stringify"]])
});
var gadgets=gadgets||{};
gadgets.util=function(){function g(m){var n;
var k=m;
var i=k.indexOf("?");
var j=k.indexOf("#");
if(j===-1){n=k.substr(i+1)
}else{n=[k.substr(i+1,j-i-1),"&",k.substr(j+1)].join("")
}return n.split("&")
}var e=null;
var d={};
var c={};
var f=[];
var a={0:false,10:true,13:true,34:true,39:true,60:true,62:true,92:true,8232:true,8233:true};
function b(i,j){return String.fromCharCode(j)
}function h(i){d=i["core.util"]||{}
}if(gadgets.config){gadgets.config.register("core.util",null,h)
}return{getUrlParameters:function(s){if(e!==null&&typeof s==="undefined"){return e
}var o={};
e={};
var l=g(s||document.location.href);
var q=window.decodeURIComponent?decodeURIComponent:unescape;
for(var n=0,m=l.length;
n<m;
++n){var p=l[n].indexOf("=");
if(p===-1){continue
}var k=l[n].substring(0,p);
var r=l[n].substring(p+1);
r=r.replace(/\+/g," ");
o[k]=q(r)
}if(typeof s==="undefined"){e=o
}return o
},makeClosure:function(n,p,o){var m=[];
for(var l=2,k=arguments.length;
l<k;
++l){m.push(arguments[l])
}return function(){var q=m.slice();
for(var s=0,r=arguments.length;
s<r;
++s){q.push(arguments[s])
}return p.apply(n,q)
}
},makeEnum:function(k){var m={};
for(var l=0,j;
(j=k[l]);
++l){m[j]=j
}return m
},getFeatureParameters:function(i){return typeof d[i]==="undefined"?null:d[i]
},hasFeature:function(i){return typeof d[i]!=="undefined"
},getServices:function(){return c
},registerOnLoadHandler:function(i){f.push(i)
},runOnLoadHandlers:function(){for(var l=0,k=f.length;
l<k;
++l){f[l]()
}},escape:function(k,o){if(!k){return k
}else{if(typeof k==="string"){return gadgets.util.escapeString(k)
}else{if(typeof k==="array"){for(var n=0,l=k.length;
n<l;
++n){k[n]=gadgets.util.escape(k[n])
}}else{if(typeof k==="object"&&o){var m={};
for(var p in k){if(k.hasOwnProperty(p)){m[gadgets.util.escapeString(p)]=gadgets.util.escape(k[p],true)
}}return m
}}}}return k
},escapeString:function(o){var l=[],n,p;
for(var m=0,k=o.length;
m<k;
++m){n=o.charCodeAt(m);
p=a[n];
if(p===true){l.push("&#",n,";")
}else{if(p!==false){l.push(o.charAt(m))
}}}return l.join("")
},unescapeString:function(i){return i.replace(/&#([0-9]+);/g,b)
}}
}();
gadgets.util.getUrlParameters();
var tamings___=tamings___||[];
tamings___.push(function(a){caja___.whitelistFuncs([[gadgets.util,"escapeString"],[gadgets.util,"getFeatureParameters"],[gadgets.util,"hasFeature"],[gadgets.util,"registerOnLoadHandler"],[gadgets.util,"unescapeString"]])
});
var gadgets=gadgets||{};
gadgets.rpctx=gadgets.rpctx||{};
gadgets.rpctx.wpm=function(){var a;
return{getCode:function(){return"wpm"
},isParentVerifiable:function(){return true
},init:function(b,c){a=c;
var d=function(e){b(gadgets.json.parse(e.data))
};
if(typeof window.addEventListener!="undefined"){window.addEventListener("message",d,false)
}else{if(typeof window.attachEvent!="undefined"){window.attachEvent("onmessage",d)
}}a("..",true);
return true
},setup:function(c,b){if(c===".."){gadgets.rpc.call(c,gadgets.rpc.ACK)
}return true
},call:function(c,f,e){var d=c===".."?window.parent:window.frames[c];
var b=gadgets.rpc.getOrigin(gadgets.rpc.getRelayUrl(c));
if(b){d.postMessage(gadgets.json.stringify(e),b)
}else{gadgets.error("No relay set (used as window.postMessage targetOrigin)"+", cannot send cross-domain message")
}return true
}}
}();
var gadgets=gadgets||{};
gadgets.rpctx=gadgets.rpctx||{};
gadgets.rpctx.frameElement=function(){var e="__g2c_rpc";
var b="__c2g_rpc";
var d;
var c;
function a(g,k,j){try{if(k!==".."){var f=window.frameElement;
if(typeof f[e]==="function"){if(typeof f[e][b]!=="function"){f[e][b]=function(l){d(gadgets.json.parse(l))
}
}f[e](gadgets.json.stringify(j));
return
}}else{var i=document.getElementById(g);
if(typeof i[e]==="function"&&typeof i[e][b]==="function"){i[e][b](gadgets.json.stringify(j));
return
}}}catch(h){}return true
}return{getCode:function(){return"fe"
},isParentVerifiable:function(){return false
},init:function(f,g){d=f;
c=g;
return true
},setup:function(j,f){if(j!==".."){try{var i=document.getElementById(j);
i[e]=function(k){d(gadgets.json.parse(k))
}
}catch(h){return false
}}if(j===".."){c("..",true);
var g=function(){window.setTimeout(function(){gadgets.rpc.call(j,gadgets.rpc.ACK)
},500)
};
gadgets.util.registerOnLoadHandler(g)
}return true
},call:function(f,h,g){a(f,h,g)
}}
}();
var gadgets=gadgets||{};
gadgets.rpctx=gadgets.rpctx||{};
gadgets.rpctx.nix=function(){var c="GRPC____NIXVBS_wrapper";
var d="GRPC____NIXVBS_get_wrapper";
var f="GRPC____NIXVBS_handle_message";
var b="GRPC____NIXVBS_create_channel";
var a=10;
var j=500;
var i={};
var h;
var g=0;
function e(){var l=i[".."];
if(l){return
}if(++g>a){gadgets.warn("Nix transport setup failed, falling back...");
h("..",false);
return
}if(!l&&window.opener&&"GetAuthToken" in window.opener){l=window.opener;
if(l.GetAuthToken()==gadgets.rpc.getAuthToken("..")){var k=gadgets.rpc.getAuthToken("..");
l.CreateChannel(window[d]("..",k),k);
i[".."]=l;
window.opener=null;
h("..",true);
return
}}window.setTimeout(function(){e()
},j)
}return{getCode:function(){return"nix"
},isParentVerifiable:function(){return false
},init:function(l,m){h=m;
if(typeof window[d]!=="unknown"){window[f]=function(o){window.setTimeout(function(){l(gadgets.json.parse(o))
},0)
};
window[b]=function(o,q,p){if(gadgets.rpc.getAuthToken(o)===p){i[o]=q;
h(o,true)
}};
var k="Class "+c+"\n "+"Private m_Intended\n"+"Private m_Auth\n"+"Public Sub SetIntendedName(name)\n "+"If isEmpty(m_Intended) Then\n"+"m_Intended = name\n"+"End If\n"+"End Sub\n"+"Public Sub SetAuth(auth)\n "+"If isEmpty(m_Auth) Then\n"+"m_Auth = auth\n"+"End If\n"+"End Sub\n"+"Public Sub SendMessage(data)\n "+f+"(data)\n"+"End Sub\n"+"Public Function GetAuthToken()\n "+"GetAuthToken = m_Auth\n"+"End Function\n"+"Public Sub CreateChannel(channel, auth)\n "+"Call "+b+"(m_Intended, channel, auth)\n"+"End Sub\n"+"End Class\n"+"Function "+d+"(name, auth)\n"+"Dim wrap\n"+"Set wrap = New "+c+"\n"+"wrap.SetIntendedName name\n"+"wrap.SetAuth auth\n"+"Set "+d+" = wrap\n"+"End Function";
try{window.execScript(k,"vbscript")
}catch(n){return false
}}return true
},setup:function(o,k){if(o===".."){e();
return true
}try{var m=document.getElementById(o);
var n=window[d](o,k);
m.contentWindow.opener=n
}catch(l){return false
}return true
},call:function(k,n,m){try{if(i[k]){i[k].SendMessage(gadgets.json.stringify(m))
}}catch(l){return false
}return true
}}
}();
var gadgets=gadgets||{};
gadgets.rpctx=gadgets.rpctx||{};
gadgets.rpctx.rmr=function(){var g=500;
var e=10;
var h={};
var b;
var i;
function k(p,n,o,m){var q=function(){document.body.appendChild(p);
p.src="about:blank";
if(m){p.onload=function(){l(m)
}
}p.src=n+"#"+o
};
if(document.body){q()
}else{gadgets.util.registerOnLoadHandler(function(){q()
})
}}function c(o){if(typeof h[o]==="object"){return
}var p=document.createElement("iframe");
var m=p.style;
m.position="absolute";
m.top="0px";
m.border="0";
m.opacity="0";
m.width="10px";
m.height="1px";
p.id="rmrtransport-"+o;
p.name=p.id;
var n=gadgets.rpc.getOrigin(gadgets.rpc.getRelayUrl(o))+"/robots.txt";
h[o]={frame:p,receiveWindow:null,relayUri:n,searchCounter:0,width:10,waiting:true,queue:[],sendId:0,recvId:0};
if(o!==".."){k(p,n,a(o))
}d(o)
}function d(n){var p=null;
h[n].searchCounter++;
try{if(n===".."){p=window.parent.frames["rmrtransport-"+gadgets.rpc.RPC_ID]
}else{p=window.frames[n].frames["rmrtransport-.."]
}}catch(o){}var m=false;
if(p){m=f(n,p)
}if(!m){if(h[n].searchCounter>e){return
}window.setTimeout(function(){d(n)
},g)
}}function j(n,p,t,s){var o=null;
if(t!==".."){o=h[".."]
}else{o=h[n]
}if(o){if(p!==gadgets.rpc.ACK){o.queue.push(s)
}if(o.waiting||(o.queue.length===0&&!(p===gadgets.rpc.ACK&&s&&s.ackAlone===true))){return true
}if(o.queue.length>0){o.waiting=true
}var m=o.relayUri+"#"+a(n);
try{o.frame.contentWindow.location=m;
var q=o.width==10?20:10;
o.frame.style.width=q+"px";
o.width=q
}catch(r){return false
}}return true
}function a(n){var o=h[n];
var m={id:o.sendId};
if(o){m.d=Array.prototype.slice.call(o.queue,0);
m.d.push({s:gadgets.rpc.ACK,id:o.recvId})
}return gadgets.json.stringify(m)
}function l(x){var u=h[x];
var q=u.receiveWindow.location.hash.substring(1);
var y=gadgets.json.parse(decodeURIComponent(q))||{};
var n=y.d||[];
var o=false;
var t=false;
var v=0;
var m=(u.recvId-y.id);
for(var p=0;
p<n.length;
++p){var s=n[p];
if(s.s===gadgets.rpc.ACK){i(x,true);
if(u.waiting){t=true
}u.waiting=false;
var r=Math.max(0,s.id-u.sendId);
u.queue.splice(0,r);
u.sendId=Math.max(u.sendId,s.id||0);
continue
}o=true;
if(++v<=m){continue
}++u.recvId;
b(s)
}if(o||(t&&u.queue.length>0)){var w=(x==="..")?gadgets.rpc.RPC_ID:"..";
j(x,gadgets.rpc.ACK,w,{ackAlone:o})
}}function f(p,s){var o=h[p];
try{var n=false;
n="document" in s;
if(!n){return false
}n=typeof s["document"]=="object";
if(!n){return false
}var r=s.location.href;
if(r==="about:blank"){return false
}}catch(m){return false
}o.receiveWindow=s;
function q(){l(p)
}if(typeof s.attachEvent==="undefined"){s.onresize=q
}else{s.attachEvent("onresize",q)
}if(p===".."){k(o.frame,o.relayUri,a(p),p)
}else{l(p)
}return true
}return{getCode:function(){return"rmr"
},isParentVerifiable:function(){return true
},init:function(m,n){b=m;
i=n;
return true
},setup:function(o,m){try{c(o)
}catch(n){gadgets.warn("Caught exception setting up RMR: "+n);
return false
}return true
},call:function(m,o,n){return j(m,n.s,o,n)
}}
}();
var gadgets=gadgets||{};
gadgets.rpctx=gadgets.rpctx||{};
gadgets.rpctx.ifpc=function(){var e=[];
var d=0;
var c;
function b(h){var f=[];
for(var k=0,g=h.length;
k<g;
++k){f.push(encodeURIComponent(gadgets.json.stringify(h[k])))
}return f.join("&")
}function a(j){var g;
for(var f=e.length-1;
f>=0;
--f){var k=e[f];
try{if(k&&(k.recyclable||k.readyState==="complete")){k.parentNode.removeChild(k);
if(window.ActiveXObject){e[f]=k=null;
e.splice(f,1)
}else{k.recyclable=false;
g=k;
break
}}}catch(h){}}if(!g){g=document.createElement("iframe");
g.style.border=g.style.width=g.style.height="0px";
g.style.visibility="hidden";
g.style.position="absolute";
g.onload=function(){this.recyclable=true
};
e.push(g)
}g.src=j;
window.setTimeout(function(){document.body.appendChild(g)
},0)
}return{getCode:function(){return"ifpc"
},isParentVerifiable:function(){return true
},init:function(f,g){c=g;
c("..",true);
return true
},setup:function(g,f){c(g,true);
return true
},call:function(f,k,i){var j=gadgets.rpc.getRelayUrl(f);
++d;
if(!j){gadgets.warn("No relay file assigned for IFPC");
return
}var h=null;
if(i.l){var g=i.a;
h=[j,"#",b([k,d,1,0,b([k,i.s,"","",k].concat(g))])].join("")
}else{h=[j,"#",f,"&",k,"@",d,"&1&0&",encodeURIComponent(gadgets.json.stringify(i))].join("")
}a(h);
return true
}}
}();
var gadgets=gadgets||{};
gadgets.rpc=function(){var s="__cb";
var r="";
var g="__ack";
var q=500;
var i=10;
var b={};
var c={};
var w={};
var j={};
var m=0;
var H={};
var v={};
var d={};
var E={};
var k={};
var u={};
var l=(window.top!==window.self);
var n=window.name;
var F=(function(){function I(J){return function(){gadgets.log("gadgets.rpc."+J+"("+gadgets.json.stringify(Array.prototype.slice.call(arguments))+"): call ignored. [caller: "+document.location+", isChild: "+l+"]")
}
}return{getCode:function(){return"noop"
},isParentVerifiable:function(){return true
},init:I("init"),setup:I("setup"),call:I("call")}
})();
if(gadgets.util){E=gadgets.util.getUrlParameters()
}var z=(E["rpc_earlyq"]==="1");
function a(){return typeof window.postMessage==="function"?gadgets.rpctx.wpm:typeof window.postMessage==="object"?gadgets.rpctx.wpm:window.ActiveXObject?gadgets.rpctx.nix:navigator.userAgent.indexOf("WebKit")>0?gadgets.rpctx.rmr:navigator.product==="Gecko"?gadgets.rpctx.frameElement:gadgets.rpctx.ifpc
}function A(N,L){var J=B;
if(!L){J=F
}k[N]=J;
var I=u[N]||[];
for(var K=0;
K<I.length;
++K){var M=I[K];
M.t=x(N);
J.call(N,M.f,M)
}u[N]=[]
}function t(J){if(J&&typeof J.s==="string"&&typeof J.f==="string"&&J.a instanceof Array){if(j[J.f]){if(j[J.f]!==J.t){throw new Error("Invalid auth token. "+j[J.f]+" vs "+J.t)
}}if(J.s===g){window.setTimeout(function(){A(J.f,true)
},0);
return
}if(J.c){J.callback=function(K){gadgets.rpc.call(J.f,s,null,J.c,K)
}
}var I=(b[J.s]||b[r]).apply(J,J.a);
if(J.c&&typeof I!=="undefined"){gadgets.rpc.call(J.f,s,null,J.c,I)
}}}function D(K){if(!K){return""
}K=K.toLowerCase();
if(K.indexOf("//")==0){K=window.location.protocol+K
}if(K.indexOf("://")==-1){K=window.location.protocol+"//"+K
}var L=K.substring(K.indexOf("://")+3);
var I=L.indexOf("/");
if(I!=-1){L=L.substring(0,I)
}var N=K.substring(0,K.indexOf("://"));
var M="";
var O=L.indexOf(":");
if(O!=-1){var J=L.substring(O+1);
L=L.substring(0,O);
if((N==="http"&&J!=="80")||(N==="https"&&J!=="443")){M=":"+J
}}return N+"://"+L+M
}var B=a();
b[r]=function(){gadgets.warn("Unknown RPC service: "+this.s)
};
b[s]=function(J,I){var K=H[J];
if(K){delete H[J];
K(I)
}};
function o(K,I){if(v[K]===true){return
}if(typeof v[K]==="undefined"){v[K]=0
}var J=document.getElementById(K);
if(K===".."||J!=null){if(B.setup(K,I)===true){v[K]=true;
return
}}if(v[K]!==true&&v[K]++<i){window.setTimeout(function(){o(K,I)
},q)
}else{k[K]=F;
v[K]=true
}}function f(J,M){if(typeof d[J]==="undefined"){d[J]=false;
var L=gadgets.rpc.getRelayUrl(J);
if(D(L)!==D(window.location.href)){return false
}var K=null;
if(J===".."){K=window.parent
}else{K=window.frames[J]
}try{d[J]=K.gadgets.rpc.receiveSameDomain
}catch(I){gadgets.error("Same domain call failed: parent= incorrectly set.")
}}if(typeof d[J]==="function"){d[J](M);
return true
}return false
}function h(J,I,K){c[J]=I;
w[J]=!!K
}function x(I){return j[I]
}function e(I,J){J=J||"";
j[I]=String(J);
o(I,J)
}function p(I){function K(N){var P=N?N.rpc:{};
var M=P.parentRelayUrl;
if(M.substring(0,7)!=="http://"&&M.substring(0,8)!=="https://"&&M.substring(0,2)!=="//"){if(typeof E.parent==="string"&&E.parent!==""){if(M.substring(0,1)!=="/"){var L=E.parent.lastIndexOf("/");
M=E.parent.substring(0,L+1)+M
}else{M=D(E.parent)+M
}}}var O=!!P.useLegacyProtocol;
h("..",M,O);
if(O){B=gadgets.rpctx.ifpc;
B.init(t,A)
}e("..",I)
}var J={parentRelayUrl:gadgets.config.NonEmptyStringValidator};
gadgets.config.register("rpc",J,K)
}function y(K,I){var J=I||E.parent;
if(J){h("..",J);
e("..",K)
}}function C(I,M,O){if(!gadgets.util){return
}var L=document.getElementById(I);
if(!L){throw new Error("Cannot set up gadgets.rpc receiver with ID: "+I+", element not found.")
}var J=M||L.src;
h(I,J);
var N=gadgets.util.getUrlParameters(L.src);
var K=O||N.rpctoken;
e(I,K)
}function G(I,K,L){if(I===".."){var J=L||E.rpctoken||E.ifpctok||"";
if(gadgets.config){p(J)
}else{y(J,K)
}}else{C(I,K,L)
}}if(l){G("..")
}return{register:function(J,I){if(J===s||J===g){throw new Error("Cannot overwrite callback/ack service")
}if(J===r){throw new Error("Cannot overwrite default service:"+" use registerDefault")
}b[J]=I
},unregister:function(I){if(I===s||I===g){throw new Error("Cannot delete callback/ack service")
}if(I===r){throw new Error("Cannot delete default service:"+" use unregisterDefault")
}delete b[I]
},registerDefault:function(I){b[r]=I
},unregisterDefault:function(){delete b[r]
},forceParentVerifiable:function(){if(!B.isParentVerifiable()){B=gadgets.rpctx.ifpc
}},call:function(I,J,O,M){I=I||"..";
var N="..";
if(I===".."){N=n
}++m;
if(O){H[m]=O
}var L={s:J,f:N,c:O?m:0,a:Array.prototype.slice.call(arguments,3),t:j[I],l:w[I]};
if(f(I,L)){return
}var K=k[I]?k[I]:B;
if(!K){if(!u[I]){u[I]=[L]
}else{u[I].push(L)
}return
}if(w[I]){K=gadgets.rpctx.ifpc
}if(K.call(I,N,L)===false){k[I]=F;
B.call(I,N,L)
}},getRelayUrl:function(J){var I=c[J];
if(I&&I.indexOf("//")==0){I=document.location.protocol+I
}return I
},setRelayUrl:h,setAuthToken:e,setupReceiver:G,getAuthToken:x,getRelayChannel:function(){return B.getCode()
},receive:function(I){if(I.length>4){t(gadgets.json.parse(decodeURIComponent(I[I.length-1])))
}},receiveSameDomain:function(I){I.a=Array.prototype.slice.call(I.a);
window.setTimeout(function(){t(I)
},0)
},getOrigin:D,init:function(){if(B.init(t,A)===false){B=F
}},ACK:g,RPC_ID:n}
}();
gadgets.rpc.init();

/* js/opensocial/util.js */

Function.prototype.inherits=function(a){function b(){}b.prototype=a.prototype;
this.superClass_=a.prototype;
this.prototype=new b();
this.prototype.constructor=this
};

/* js/opensocial/gadgets.js */

var gadgets=gadgets||{};
gadgets.errors=gadgets.errors||{};
gadgets.errors.SUBCLASS_RESPONSIBILITY="subclass responsibility";
gadgets.errors.TO_BE_DONE="to be done";
gadgets.callAsyncAndJoin=function(e,a,d){var f=e.length;
var c=[];
for(var b=0;
b<e.length;
b++){var g=function(h){e[h].call(d,function(i){c[h]=i;
if(--f===0){a(c)
}})
};
g(b)
}};
gadgets.Extensible=function(){};
gadgets.Extensible.prototype.setDependencies=function(a){for(var b in a){this[b]=a[b]
}};
gadgets.Extensible.prototype.getDependencies=function(a){return this[a]
};
gadgets.UserPrefStore=function(){};
gadgets.UserPrefStore.prototype.getPrefs=function(a){throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY)
};
gadgets.UserPrefStore.prototype.savePrefs=function(a){throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY)
};
gadgets.DefaultUserPrefStore=function(){gadgets.UserPrefStore.call(this)
};
gadgets.DefaultUserPrefStore.inherits(gadgets.UserPrefStore);
gadgets.DefaultUserPrefStore.prototype.getPrefs=function(a){};
gadgets.DefaultUserPrefStore.prototype.savePrefs=function(a){};
gadgets.GadgetService=function(){};
gadgets.GadgetService.prototype.setHeight=function(b,a){throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY)
};
gadgets.GadgetService.prototype.setTitle=function(a,b){throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY)
};
gadgets.GadgetService.prototype.setUserPref=function(a){throw Error(gadgets.error.SUBCLASS_RESPONSIBILITY)
};
gadgets.IfrGadgetService=function(){gadgets.GadgetService.call(this);
gadgets.rpc.register("resize_iframe",this.setHeight);
gadgets.rpc.register("set_pref",this.setUserPref);
gadgets.rpc.register("set_title",this.setTitle);
gadgets.rpc.register("requestNavigateTo",this.requestNavigateTo)
};
gadgets.IfrGadgetService.inherits(gadgets.GadgetService);
gadgets.IfrGadgetService.prototype.setHeight=function(a){var c,b;
var d="cannot find div for ";
if(a>gadgets.container.maxheight_){a=gadgets.container.maxheight_
}if(gadgets.container.view_==="profile"){b=this.f.replace(/-remote/,"");
c=document.getElementById(b);
if(c){if(a===0){c.style.display="none"
}else{c.style.display="";
c.style.visibility="";
c.style.position="";
c.style.left=""
}}else{gadgets.log(d+b)
}}c=document.getElementById(this.f);
if(c){c.style.height=a+"px"
}else{gadgets.log(d+this.f)
}};
gadgets.IfrGadgetService.prototype.setTitle=function(b){var a=document.getElementById(this.f+"_title");
if(a){a.innerHTML=b.replace(/&/g,"&amp;").replace(/</g,"&lt;")
}};
gadgets.IfrGadgetService.prototype.setUserPref=function(h,c,e){var g=gadgets.container.gadgetService.getGadgetIdFromModuleId(this.f);
var f=gadgets.container.getGadget(g);
var b=f.getUserPrefs()||{};
for(var d=1,a=arguments.length;
d<a;
d+=2){b[arguments[d]]=arguments[d+1]
}f.setUserPrefs(b)
};
gadgets.IfrGadgetService.prototype.requestNavigateTo=function(a,d){var e=gadgets.container.gadgetService.getGadgetIdFromModuleId(this.f);
var b=gadgets.container.gadgetService.getUrlForView(a);
if(d){var c=gadgets.json.stringify(d);
if(c.length>0){b+="&appParams="+encodeURIComponent(c)
}}if(b&&document.location.href.indexOf(b)==-1){document.location.href=b
}};
gadgets.IfrGadgetService.prototype.getUrlForView=function(a){if(a==="canvas"){return"/canvas"
}else{if(a==="profile"){return"/profile"
}else{return null
}}};
gadgets.IfrGadgetService.prototype.getGadgetIdFromModuleId=function(a){return parseInt(a.match(/_([0-9]+)$/)[1],10)
};
gadgets.LayoutManager=function(){};
gadgets.LayoutManager.prototype.getGadgetChrome=function(a){throw Error(gadgets.errors.SUBCLASS_RESPONSIBILITY)
};
gadgets.StaticLayoutManager=function(){gadgets.LayoutManager.call(this)
};
gadgets.StaticLayoutManager.inherits(gadgets.LayoutManager);
gadgets.StaticLayoutManager.prototype.setGadgetChromeIds=function(a){this.gadgetChromeIds_=a
};
gadgets.StaticLayoutManager.prototype.getGadgetChrome=function(b){var a=this.gadgetChromeIds_[b.id];
return a?document.getElementById(a):null
};
gadgets.FloatLeftLayoutManager=function(a){gadgets.LayoutManager.call(this);
this.layoutRootId_=a
};
gadgets.FloatLeftLayoutManager.inherits(gadgets.LayoutManager);
gadgets.FloatLeftLayoutManager.prototype.getGadgetChrome=function(c){var b=document.getElementById(this.layoutRootId_);
if(b){var a=document.createElement("div");
a.className="gadgets-gadget-chrome";
a.style.cssFloat="left";
b.appendChild(a);
return a
}else{return null
}};
gadgets.Gadget=function(b){this.userPrefs_={};
if(b){for(var a in b){if(b.hasOwnProperty(a)){this[a]=b[a]
}}}};
gadgets.Gadget.prototype.getUserPrefs=function(){return this.userPrefs_
};
gadgets.Gadget.prototype.setUserPrefs=function(a){this.userPrefs_=a;
gadgets.container.userPrefStore.savePrefs(this)
};
gadgets.Gadget.prototype.getUserPref=function(a){return this.userPrefs_[a]
};
gadgets.Gadget.prototype.setUserPref=function(a,b){this.userPrefs_[a]=b;
gadgets.container.userPrefStore.savePrefs(this)
};
gadgets.Gadget.prototype.render=function(a){if(a){var b=this;
this.getContent(function(c){a.innerHTML=c;
window.frames[b.getIframeId()].location.replace(b.getIframeUrl())
})
}};
gadgets.Gadget.prototype.getContent=function(a){gadgets.callAsyncAndJoin([this.getTitleBarContent,this.getUserPrefsDialogContent,this.getMainContent],function(b){a(b.join(""))
},this)
};
gadgets.Gadget.prototype.getTitleBarContent=function(a){throw Error(gadgets.errors.SUBCLASS_RESPONSIBILITY)
};
gadgets.Gadget.prototype.getUserPrefsDialogContent=function(a){throw Error(gadgets.errors.SUBCLASS_RESPONSIBILITY)
};
gadgets.Gadget.prototype.getMainContent=function(a){throw Error(gadgets.errors.SUBCLASS_RESPONSIBILITY)
};
gadgets.Gadget.prototype.getAdditionalParams=function(){return""
};
gadgets.IfrGadget=function(a){gadgets.Gadget.call(this,a);
this.serverBase_="../../"
};
gadgets.IfrGadget.inherits(gadgets.Gadget);
gadgets.IfrGadget.prototype.GADGET_IFRAME_PREFIX_="remote_iframe_";
gadgets.IfrGadget.prototype.CONTAINER="default";
gadgets.IfrGadget.prototype.cssClassGadget="gadgets-gadget";
gadgets.IfrGadget.prototype.cssClassTitleBar="gadgets-gadget-title-bar";
gadgets.IfrGadget.prototype.cssClassTitle="gadgets-gadget-title";
gadgets.IfrGadget.prototype.cssClassTitleButtonBar="gadgets-gadget-title-button-bar";
gadgets.IfrGadget.prototype.cssClassGadgetUserPrefsDialog="gadgets-gadget-user-prefs-dialog";
gadgets.IfrGadget.prototype.cssClassGadgetUserPrefsDialogActionBar="gadgets-gadget-user-prefs-dialog-action-bar";
gadgets.IfrGadget.prototype.cssClassTitleButton="gadgets-gadget-title-button";
gadgets.IfrGadget.prototype.cssClassGadgetContent="gadgets-gadget-content";
gadgets.IfrGadget.prototype.rpcToken=(2147483647*Math.random())|0;
gadgets.IfrGadget.prototype.rpcRelay="files/container/rpc_relay.html";
gadgets.IfrGadget.prototype.getTitleBarContent=function(a){a('<div id="'+this.cssClassTitleBar+"-"+this.id+'" class="'+this.cssClassTitleBar+'"><span id="'+this.getIframeId()+'_title" class="'+this.cssClassTitle+'">'+(this.title?this.title:"Title")+'</span> | <span class="'+this.cssClassTitleButtonBar+'"><a href="#" onclick="gadgets.container.getGadget('+this.id+').handleOpenUserPrefsDialog();return false;" class="'+this.cssClassTitleButton+'">settings</a> <a href="#" onclick="gadgets.container.getGadget('+this.id+').handleToggle();return false;" class="'+this.cssClassTitleButton+'">toggle</a></span></div>')
};
gadgets.IfrGadget.prototype.getUserPrefsDialogContent=function(a){a('<div id="'+this.getUserPrefsDialogId()+'" class="'+this.cssClassGadgetUserPrefsDialog+'"></div>')
};
gadgets.IfrGadget.prototype.setServerBase=function(a){this.serverBase_=a
};
gadgets.IfrGadget.prototype.getServerBase=function(){return this.serverBase_
};
gadgets.resetFrame=function(a){};
gadgets.IfrGadget.prototype.getMainContent=function(a){var b=this.getIframeId();
gadgets.rpc.setRelayUrl(b,this.serverBase_+this.rpcRelay);
gadgets.rpc.setAuthToken(b,this.rpcToken);
a('<div class="'+this.cssClassGadgetContent+'"><iframe id="'+b+'" name="'+b+'" class="'+this.cssClassGadget+'" src="about:blank'+'" frameborder="no" scrolling="no"'+(this.height?' height="'+this.height+'"':"")+' onload="gadgets.resetFrame(this);" '+(this.width?' width="'+this.width+'"':"")+"></iframe></div>")
};
gadgets.IfrGadget.prototype.getIframeId=function(){return this.GADGET_IFRAME_PREFIX_+this.id
};
gadgets.IfrGadget.prototype.getUserPrefsDialogId=function(){return this.getIframeId()+"_userPrefsDialog"
};
gadgets.IfrGadget.prototype.getIframeUrl=function(){return this.serverBase_+"ifr?"+"container="+this.CONTAINER+"&mid="+this.id+"&nocache="+gadgets.container.nocache_+"&urlToCanvasView="+encodeURIComponent(this.urlToCanvasView)+"&signedUrlToCanvasView="+encodeURIComponent(this.signedUrlToCanvasView)+"&country="+gadgets.container.country_+"&lang="+gadgets.container.language_+"&view="+gadgets.container.view_+(this.specVersion?"&v="+this.specVersion:"")+(gadgets.container.parentUrl_?"&parent="+encodeURIComponent(gadgets.container.parentUrl_):"")+(this.debug?"&debug=1":"")+this.getAdditionalParams()+this.getUserPrefsParams()+(this.secureToken?"&st="+this.secureToken:"")+"#rpctoken="+this.rpcToken+(this.viewParams?"&view-params="+encodeURIComponent(gadgets.json.stringify(this.viewParams)):"")+(this.hashData?"&"+this.hashData:"")
};
gadgets.IfrGadget.prototype.getUserPrefsParams=function(){var c="";
if(this.getUserPrefs()){for(var a in this.getUserPrefs()){var b=this.getUserPref(a);
c+="&up_"+encodeURIComponent(a)+"="+encodeURIComponent(b)
}}return c
};
gadgets.IfrGadget.prototype.handleToggle=function(){var b=document.getElementById(this.getIframeId());
if(b){var a=b.parentNode;
var c=a.style.display;
a.style.display=c?"":"none"
}};
gadgets.IfrGadget.prototype.handleOpenUserPrefsDialog=function(){if(this.userPrefsDialogContentLoaded){this.showUserPrefsDialog()
}else{var c=this;
var b="ig_callback_"+this.id;
window[b]=function(d){c.userPrefsDialogContentLoaded=true;
c.buildUserPrefsDialog(d);
c.showUserPrefsDialog()
};
var a=document.createElement("script");
a.src="http://gmodules.com/ig/gadgetsettings?url="+this.specUrl+"&mid="+this.id+"&output=js"+this.getUserPrefsParams();
document.body.appendChild(a)
}};
gadgets.IfrGadget.prototype.buildUserPrefsDialog=function(a){var b=document.getElementById(this.getUserPrefsDialogId());
b.innerHTML=a+'<div class="'+this.cssClassGadgetUserPrefsDialogActionBar+'"><input type="button" value="Save" onclick="gadgets.container.getGadget('+this.id+').handleSaveUserPrefs()"> <input type="button" value="Cancel" onclick="gadgets.container.getGadget('+this.id+').handleCancelUserPrefs()"></div>';
b.childNodes[0].style.display=""
};
gadgets.IfrGadget.prototype.showUserPrefsDialog=function(a){var b=document.getElementById(this.getUserPrefsDialogId());
b.style.display=(a||a===undefined)?"":"none"
};
gadgets.IfrGadget.prototype.hideUserPrefsDialog=function(){this.showUserPrefsDialog(false)
};
gadgets.IfrGadget.prototype.handleSaveUserPrefs=function(){this.hideUserPrefsDialog();
var d={};
var a=document.getElementById("m_"+this.id+"_numfields").value;
for(var e=0;
e<a;
e++){var b=document.getElementById("m_"+this.id+"_"+e);
if(b.type!="hidden"){var g="m_"+this.id+"_up_";
var c=b.name.substring(g.length);
var f=b.value;
d[c]=f
}}this.setUserPrefs(d);
this.refresh()
};
gadgets.IfrGadget.prototype.handleCancelUserPrefs=function(){this.hideUserPrefsDialog()
};
gadgets.IfrGadget.prototype.refresh=function(){var a=this.getIframeId();
document.getElementById(a).src=this.getIframeUrl()
};
gadgets.Container=function(){this.gadgets_={};
this.parentUrl_="http://"+document.location.host;
this.country_="ALL";
this.language_="ALL";
this.view_="default";
this.nocache_=0;
this.maxheight_=2147483647
};
gadgets.Container.inherits(gadgets.Extensible);
gadgets.Container.prototype.gadgetClass=gadgets.Gadget;
gadgets.Container.prototype.userPrefStore=new gadgets.DefaultUserPrefStore();
gadgets.Container.prototype.gadgetService=new gadgets.GadgetService();
gadgets.Container.prototype.layoutManager=new gadgets.StaticLayoutManager();
gadgets.Container.prototype.setParentUrl=function(a){this.parentUrl_=a
};
gadgets.Container.prototype.setCountry=function(a){this.country_=a
};
gadgets.Container.prototype.setNoCache=function(a){this.nocache_=a
};
gadgets.Container.prototype.setLanguage=function(a){this.language_=a
};
gadgets.Container.prototype.setView=function(a){this.view_=a
};
gadgets.Container.prototype.setMaxHeight=function(a){this.maxheight_=a
};
gadgets.Container.prototype.getGadgetKey_=function(a){return"gadget_"+a
};
gadgets.Container.prototype.getGadget=function(a){return this.gadgets_[this.getGadgetKey_(a)]
};
gadgets.Container.prototype.createGadget=function(a){return new this.gadgetClass(a)
};
gadgets.Container.prototype.addGadget=function(a){a.id=this.getNextGadgetInstanceId();
a.setUserPrefs(this.userPrefStore.getPrefs(a));
this.gadgets_[this.getGadgetKey_(a.id)]=a
};
gadgets.Container.prototype.addGadgets=function(a){for(var b=0;
b<a.length;
b++){this.addGadget(a[b])
}};
gadgets.Container.prototype.renderGadgets=function(){for(var a in this.gadgets_){this.renderGadget(this.gadgets_[a])
}};
gadgets.Container.prototype.renderGadget=function(a){throw Error(gadgets.errors.SUBCLASS_RESPONSIBILITY)
};
gadgets.Container.prototype.nextGadgetInstanceId_=0;
gadgets.Container.prototype.getNextGadgetInstanceId=function(){return this.nextGadgetInstanceId_++
};
gadgets.Container.prototype.refreshGadgets=function(){for(var a in this.gadgets_){this.gadgets_[a].refresh()
}};
gadgets.IfrContainer=function(){gadgets.Container.call(this)
};
gadgets.IfrContainer.inherits(gadgets.Container);
gadgets.IfrContainer.prototype.gadgetClass=gadgets.IfrGadget;
gadgets.IfrContainer.prototype.gadgetService=new gadgets.IfrGadgetService();
gadgets.IfrContainer.prototype.setParentUrl=function(a){if(!a.match(/^http[s]?:\/\//)){a=document.location.href.match(/^[^?#]+\//)[0]+a
}this.parentUrl_=a
};
gadgets.IfrContainer.prototype.renderGadget=function(b){var a=this.layoutManager.getGadgetChrome(b);
b.render(a)
};
gadgets.container=new gadgets.IfrContainer();

/* js/opensocial/gadget_container.js */

gadgets.ChameleonLayoutManager=function(a){gadgets.StaticLayoutManager.call(this,a);
this.gadgetChromeMap_=new Array()
};
gadgets.ChameleonLayoutManager.inherits(gadgets.StaticLayoutManager);
gadgets.ChameleonLayoutManager.prototype.addGadgetChrome=function(b,a){this.gadgetChromeMap_[b]=a
};
gadgets.ChameleonLayoutManager.prototype.getGadgetChrome=function(b){var a=this.gadgetChromeMap_[b.id];
return a?document.getElementById(a):null
};
gadgets.ChameleonGadget=function(a){gadgets.IfrGadget.call(this,a);
this.pageID_=0;
this.panelID_=0;
this.appID_=0
};
gadgets.ChameleonGadget.prototype.getPageID=function(){return this.pageID_
};
gadgets.ChameleonGadget.prototype.getPanelID=function(){return this.panelID_
};
gadgets.ChameleonGadget.prototype.getAppID=function(){return this.appID_
};
gadgets.ChameleonGadget.inherits(gadgets.IfrGadget);
gadgets.ChameleonGadget.prototype.cssClassGadgetContent="content";
gadgets.ChameleonGadget.prototype.cssClassTitleBar="header";
gadgets.ChameleonGadget.prototype.GADGET_IFRAME_PREFIX_="";
gadgets.ChameleonGadget.prototype.rpcRelay="js/opensocial/rpc_relay.html";
gadgets.ChameleonGadget.prototype.getIframeId=function(){return"panel-0"+this.panelID_+"-slot-"+this.appID_+"-remote"
};
gadgets.ChameleonGadget.prototype.getTitleBarContent=function(c){var d="";
var b=gadgets.container.view_?gadgets.container.view_.split(".")[0]:"";
var a,e;
if(LI&&LI.i18n){a=LI.i18.get("profile-view-remove");
e=LI.i18.get("profile-view-close")
}if(b=="canvas"){c("")
}else{if(b=="profile"){c('<div class="'+this.cssClassTitleBar+'" id="'+this.getTitleBarId()+'"><h3><strong id="'+"panel-0"+this.panelID_+"-slot-"+this.appID_+'-remote-title">'+(this.title?this.title:d)+'</strong> <span class="edit">[ <a class="close" href="#">'+(a?a:"Remove")+"</a> ]</span></h3></div>")
}else{c('<div class="'+this.cssClassTitleBar+'" id="'+this.getTitleBarId()+'"><h4 title="'+(this.title?this.title:d)+'"><strong id="'+"panel-0"+this.panelID_+"-slot-"+this.appID_+'-remote-title">'+(this.title?this.title:d)+"</strong></h4>"+'<ul><li class="close"><a href="#">'+(e?e:"Close")+"</a></li></ul></div>")
}}};
gadgets.ChameleonGadget.prototype.getUserPrefsDialogContent=function(a){a("")
};
gadgets.ChameleonGadget.prototype.getTitleBarId=function(){return"panel-0"+this.panelID_+"-slot-"+this.appID_+"-header"
};
gadgets.ChameleonGadget.prototype.getSlotId=function(){return"panel-0"+this.panelID_+"-slot-"+this.appID_
};
gadgets.ChameleonGadget.prototype.handleToggle=function(){};
gadgets.ChameleonGadget.prototype.setGadgetInfo=function(i,j,f,n,h,e,k,b,l,a,m,c,g,d){this.pageID_=i;
this.panelID_=j;
this.appID_=f;
this.urlToCanvasView=n;
this.signedUrlToCanvasView=h;
this.baseLeoNonSecureURL=e;
this.ownerProfileUrl=k;
this.viewerId=b;
this.ownerId=l;
this.applicationId=a;
this.viewerAccess=m;
this.isViewerTheOwner=c;
this.language=g;
this.country=d
};
function makeXhr(){if(window.XMLHttpRequest){return new XMLHttpRequest()
}else{if(window.ActiveXObject){var a=new ActiveXObject("Msxml2.XMLHTTP");
if(!a){a=new ActiveXObject("Microsoft.XMLHTTP")
}return a
}}}gadgets.ChameleonGadget.prototype.handleOpenUserPrefsDialog=function(){if(this.userPrefsDialogContentLoaded){this.showUserPrefsDialog()
}else{var c=this;
var b={context:{country:"US",language:"en",view:"default",container:"default"},gadgets:[{url:c.specUrl,moduleId:c.id}]};
var d=makeXhr();
d.open("POST","/opensocial/metadata",true);
d.onreadystatechange=function(e){return function(){if(d.readyState!==4){return
}var n=gadgets.json.parse(d.responseText);
var m=n.gadgets;
var o={};
for(var l=0,p;
p=m[l];
++l){var k=p.features||[];
for(var f=0,h;
h=k[f];
++f){o[h]=true
}}}
}(d);
var a=gadgets.json.stringify(b);
d.send(a)
}};
gadgets.ChameleonGadget.prototype.render=function(a){if(gadgets.container.view_=="canvas"){}gadgets.IfrGadget.prototype.render.apply(this,[a]);
setupModules.initSlot(this.getSlotId(),false,true)
};
gadgets.ChameleonGadget.prototype.getIframeUrl=function(){var a=gadgets.util.getUrlParameters().appParams;
return this.serverBase_+"opensocial/ifr?"+"url="+encodeURIComponent(this.specUrl)+"&synd=default"+"&mid="+this.id+"&nocache="+gadgets.container.nocache_+"&urlToCanvasView="+encodeURIComponent(this.urlToCanvasView)+"&signedUrlToCanvasView="+encodeURIComponent(this.signedUrlToCanvasView)+"&baseLeoNonSecureURL="+encodeURIComponent(this.baseLeoNonSecureURL)+"&ownerProfileUrl="+encodeURIComponent(this.ownerProfileUrl)+"&viewerAccess="+encodeURIComponent(this.viewerAccess)+"&country="+this.country+"&lang="+this.language+"&view="+gadgets.container.view_+(this.specVersion?"&v="+this.specVersion:"")+(gadgets.container.parentUrl_?"&parent="+encodeURIComponent(gadgets.container.parentUrl_):"")+(this.debug?"&debug=1":"")+this.getAdditionalParams()+this.getUserPrefsParams()+"#rpctoken="+this.rpcToken+(this.secureToken?"&st="+this.secureToken:"")+(a?"&view-params="+encodeURIComponent(a):"")+(this.hashData?"&"+this.hashData:"")
};
gadgets.ChameleonUserPrefStore=function(){gadgets.UserPrefStore.call(this)
};
gadgets.ChameleonUserPrefStore.inherits(gadgets.UserPrefStore);
gadgets.ChameleonUserPrefStore.prototype.getPrefs=function(a){return a.getUserPrefs()
};
gadgets.ChameleonUserPrefStore.prototype.savePrefs=function(b){var a=b.getUserPrefs();
if(b.isViewerTheOwner){ChameleonService.savePrefs(a,b.pageID_,b.panelID_,b.appID_)
}};
gadgets.ChameleonGadgetService=function(){gadgets.IfrGadgetService.call(this);
gadgets.rpc.register("requestSendMessage",this.requestSendMessage);
gadgets.rpc.register("requestPermission",this.requestPermission)
};
gadgets.ChameleonGadgetService.inherits(gadgets.IfrGadgetService);
gadgets.ChameleonGadgetService.prototype.requestPermission=function(b,g,c){var h=gadgets.container.gadgetService.getGadgetIdFromModuleId(this.f);
var f=gadgets.container.getGadget(h);
var a=f.viewerId;
var e=f.applicationId;
var d=['<div class="interrupt">','<div class="alert attention"><p><strong>This application would like access to your profile information in order to continue.</strong></p></div>','<p class="actions">','<input type="button" value="OK, allow access" class="btn-primary" id="app-request-ok">&nbsp;','<input type="button" value="Don\'t allow access" class="btn-secondary" id="app-request-no">&nbsp;',"or&nbsp;",'<a href="/home" id="app-request-cancel">Cancel</a>',"</p>","</div>"].join("");
LI.Dialog().open({name:"openSocialConfirm",type:"interrupt",width:500,content:{html:d,title:"Application Request"}});
YEvent.on("app-request-ok","click",function(){LI.Dialog().close();
ChameleonService.grantPermission(b,a,e);
window.location.reload()
});
YEvent.on("app-request-no","click",function(){LI.Dialog().close();
window.location.reload()
});
YEvent.on("app-request-cancel","click",function(i){LI.Dialog().close();
YAHOO.util.Event.preventDefault(i);
window.history.back()
})
};
gadgets.ChameleonGadgetService.prototype.requestSendMessage=function(b,i,k,m,l,j,h,o,a,n){var c=gadgets.container.gadgetService.getGadgetIdFromModuleId(this.f);
var g=gadgets.container.getGadget(c);
if((h=="profile"||m=="profile")&&(o||l)){if(o&&!l){if(n){l="0"
}var f=gadgets.ChameleonGadgetService.getUrlFor(m,j,l,g,false);
var d=gadgets.ChameleonGadgetService.translateIds([o],g);
ChameleonService.getProfileUrlFor(d,g.secureToken,function(p){gadgets.ChameleonGadgetService.requestSendMessageHelper(b,i,k,m,l,j,h,o,a,n,g,f,p[0])
})
}else{if(!o&&l){var e=undefined;
if(h||o||a){e=gadgets.ChameleonGadgetService.getUrlFor(h,a,o,g,true)
}var d=gadgets.ChameleonGadgetService.translateIds([l],g);
ChameleonService.getProfileUrlFor(d,g.secureToken,function(p){gadgets.ChameleonGadgetService.requestSendMessageHelper(b,i,k,m,l,j,h,o,a,n,g,p[0],e)
})
}else{var d=gadgets.ChameleonGadgetService.translateIds([l,o],g);
ChameleonService.getProfileUrlFor(d,g.secureToken,function(p){gadgets.ChameleonGadgetService.requestSendMessageHelper(b,i,k,m,l,j,h,o,a,n,g,p[0],p[1])
})
}}}else{if(n){l="0"
}var f=gadgets.ChameleonGadgetService.getUrlFor(m,j,l,g,false);
var e=undefined;
if(h||o||a){e=gadgets.ChameleonGadgetService.getUrlFor(h,a,o,g,true)
}gadgets.ChameleonGadgetService.requestSendMessageHelper(b,i,k,m,l,j,h,o,a,n,g,f,e)
}};
gadgets.ChameleonGadgetService.requestSendMessageHelper=function(j,k,g,e,p,u,w,s,x,o,d,y,r){var f=(e&&e!="");
var t=document.createElement("FORM");
document.body.appendChild(t);
t.method="POST";
t.name="_LI_requestSendMessageForm";
t.id="_LI_requestSendMessageForm";
var i=new Lui.Url(lui.goback.agbpushHref("/dummy")).getParameterValueByKey(Lui.GoBack.GOBACK);
t.action=d.baseLeoNonSecureURL+"msgToConns?displayCreate=&"+Lui.GoBack.GOBACK+"="+i+"&st="+d.secureToken;
var l=document.createElement("input");
l.type="text";
l.name="recipients";
l.value=j;
t.appendChild(l);
var n=document.createElement("textarea");
n.name="body";
n.value=gadgets.util.unescapeString(k);
t.appendChild(n);
if(f){var b=document.createElement("textarea");
b.name="openSocialAppBodySuffix";
b.value='For more details, go <a href="'+y+'">here</a>.';
t.appendChild(b)
}var v=document.createElement("input");
v.name="st";
v.value=d.secureToken;
t.appendChild(v);
var q=document.createElement("input");
q.type="text";
q.name="subject";
q.value=gadgets.util.unescapeString(g);
t.appendChild(q);
var h=document.createElement("input");
h.type="text";
h.name="opensocialRecipientIds";
h.value=j;
t.appendChild(h);
var m=document.createElement("input");
m.type="hidden";
m.name="osbetafilter";
t.appendChild(m);
if(r){var a=document.createElement("input");
a.type="hidden";
a.name="viewerDestinationUrl";
a.value=r;
t.appendChild(a)
}var c=document.createElement("input");
c.type="hidden";
c.name="osappid";
c.value=d.applicationId;
t.appendChild(c);
t.submit()
};
gadgets.ChameleonGadgetService.prototype.setTitle=function(c){var a=this.f+"-title";
var b=document.getElementById(a);
if(!b){b=document.getElementById("opensocial-gadget-title")
}if(b){if(typeof b.innerText=="undefined"){b.textContent=c
}else{b.innerText=c
}if(gadgets.container.view_==="profile"&&!c){b.style.visibility="hidden";
b.style.display="none"
}}else{gadgets.log("cannot find element2 "+a)
}};
gadgets.ChameleonGadgetService.prototype.requestNavigateTo=function(b,c,a){var f=gadgets.container.gadgetService.getGadgetIdFromModuleId(this.f);
var d=gadgets.container.getGadget(f);
if(b=="profile"&&a){var e=gadgets.ChameleonGadgetService.translateIds([a],d);
ChameleonService.getProfileUrlFor(e,d.secureToken,function(g){window.location=g[0]
})
}else{window.location=gadgets.ChameleonGadgetService.getUrlFor(b,c,a,d,true)
}};
gadgets.ChameleonGadgetService.translateIds=function(b,c){var d=new Array(b.length);
for(var a=0;
a<b.length;
a++){if(b[a]=="VIEWER"){d[a]=c.viewerId
}else{if(b[a]=="OWNER"){d[a]=c.ownerId
}else{d[a]=b[a]
}}}return d
};
gadgets.ChameleonGadgetService.getUrlFor=function(h,c,i,d,g){var a="";
if(c&&c!=""&&gadgets.json.stringify(c)!="{}"){var e=gadgets.json.stringify(c);
if(e.length>0){a="appParams="+encodeURIComponent(e)
}}var k="_ownerId="+d.ownerId;
if(i){k="_ownerId="+i
}var b=h?h.split(".")[0]:"";
if(b=="canvas"){var f=(h!=b)?"&view="+h:"";
if(a==""&&!i){if(g){return d.signedUrlToCanvasView+f
}else{var j=d.urlToCanvasView+f;
return j+((j.substring(j.length-1,j.length)=="&")?k:("&"+k))
}}else{if(g){var j=d.serverBase_+"opensocial/osRedirectServlet?st="+d.secureToken+"&redirectTo="+encodeURIComponent(d.urlToCanvasView+"&"+a);
return j+((j.substring(j.length-1,j.length)=="&")?k+f:("&"+k+f))
}else{var j=d.urlToCanvasView+"&"+a;
return j+((j.substring(j.length-1,j.length)=="&")?k+f:("&"+k+f))
}}}if(b=="home"){return d.baseLeoNonSecureURL
}if(b=="profile"){return d.ownerProfileUrl
}return d.baseLeoNonSecureURL
};
gadgets.ChameleonGadgetService.prototype.getGadgetIdFromModuleId=function(a){var b=a.match(/([0-9]+)/g);
return parseInt(b[1],10)
};
gadgets.ChameleonContainer=function(a){gadgets.IfrContainer.call(this);
this.pageID_=a;
this.gadgetCount_=0;
this.gadgetChromeIDs_=new Array()
};
gadgets.ChameleonContainer.inherits(gadgets.IfrContainer);
gadgets.ChameleonContainer.prototype.gadgetClass=gadgets.ChameleonGadget;
gadgets.ChameleonContainer.prototype.gadgetService=new gadgets.ChameleonGadgetService();
gadgets.ChameleonContainer.prototype.addGadgetChrome=function(a,b){this.gadgetChromeIDs_[this.gadgetCount_++]=b;
this.layoutManager.addGadgetChrome(a,b)
};
gadgets.ChameleonContainer.prototype.renderGadgets=function(){this.layoutManager.setGadgetChromeIds(this.gadgetChromeIDs_);
gadgets.IfrContainer.prototype.renderGadgets.apply(this)
};
gadgets.ChameleonContainer.prototype.userPrefStore=new gadgets.ChameleonUserPrefStore();
gadgets.ChameleonContainer.prototype.layoutManager=new gadgets.ChameleonLayoutManager();
gadgets.ChameleonContainer.prototype.addGadget=function(a){this.gadgets_[this.getGadgetKey_(a.id)]=a
};
gadgets.ChameleonContainer.prototype.createGadget=function(b){var a=this.view_?this.view_.split(".")[0]:"";
if(a=="profile"){b.height=0;
b.width=440
}else{if(a=="home"){b.height=250;
b.width=290
}else{if(a=="canvas"){b.height=600;
b.width="100%"
}}}return gadgets.IfrContainer.prototype.createGadget.apply(this,[b])
};
gadgets.ChameleonContainer.prototype.getNextGadgetInstanceId=function(){throw Error("operation not supported")
};
gadgets.ChameleonContainer.prototype.setView=function(b){this.view_=b;
var a=b?b.split(".")[0]:"";
if(a=="canvas"){}else{if(a=="profile"){this.maxheight_=500
}else{if(a=="home"){this.maxheight_=535
}}}};
gadgets.ChameleonContainer.prototype.getView=function(){return this.view_
};